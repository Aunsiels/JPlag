3       use rusty_v8 as v8;
        |USE|USE_ITEM
5       use crate::bindings;
        |USE|USE_ITEM     |
6       use crate::error::attach_handle_to_error;
        |USE|USE_ITEM                          |
7       use crate::error::generic_error;
        |USE|USE_ITEM                 |
8       use crate::error::AnyError;
        |USE|USE_ITEM            |
9       use crate::error::ErrWithV8Handle;
        |USE|USE_ITEM                   |
10      use crate::error::JsError;
        |USE|USE_ITEM           |
11      use crate::futures::FutureExt;
        |USE|USE_ITEM               |
12      use crate::module_specifier::ModuleSpecifier;
        |USE|USE_ITEM                              |
13      use crate::modules::LoadState;
        |USE|USE_ITEM               |
14      use crate::modules::ModuleId;
        |USE|USE_ITEM              |
15      use crate::modules::ModuleLoadId;
        |USE|USE_ITEM                  |
16      use crate::modules::ModuleLoader;
        |USE|USE_ITEM                  |
17      use crate::modules::ModuleSource;
        |USE|USE_ITEM                  |
18      use crate::modules::Modules;
        |USE|USE_ITEM             |
19      use crate::modules::NoopModuleLoader;
        |USE|USE_ITEM                      |
20      use crate::modules::PrepareLoadFuture;
        |USE|USE_ITEM                       |
21      use crate::modules::RecursiveModuleLoad;
        |USE|USE_ITEM                         |
22      use crate::ops::*;
        |USE            |use_item
23      use crate::shared_queue::SharedQueue;
        |USE|USE_ITEM                      |
24      use crate::shared_queue::RECOMMENDED_SIZE;
        |USE|USE_ITEM                           |
25      use crate::BufVec;
        |USE|USE_ITEM   |
26      use crate::OpState;
        |USE|USE_ITEM    |
27      use futures::channel::mpsc;
        |USE|USE_ITEM            |
28      use futures::future::poll_fn;
        |USE|USE_ITEM              |
29      use futures::stream::FuturesUnordered;
        |USE|USE_ITEM                       |
30      use futures::stream::StreamExt;
        |USE|USE_ITEM                |
31      use futures::stream::StreamFuture;
        |USE|USE_ITEM                   |
32      use futures::task::AtomicWaker;
        |USE|USE_ITEM                |
33      use futures::Future;
        |USE|USE_ITEM     |
34      use std::any::Any;
        |USE|USE_ITEM   |
35      use std::cell::Cell;
        |USE|USE_ITEM     |
36      use std::cell::RefCell;
        |USE|USE_ITEM        |
37      use std::collections::HashMap;
        |USE|USE_ITEM               |
38      use std::convert::TryFrom;
        |USE|USE_ITEM           |
39      use std::ffi::c_void;
        |USE|USE_ITEM      |
40      use std::mem::forget;
        |USE|USE_ITEM      |
41      use std::option::Option;
        |USE|USE_ITEM         |
42      use std::pin::Pin;
        |USE|USE_ITEM   |
43      use std::rc::Rc;
        |USE|USE_ITEM |
44      use std::sync::Once;
        |USE|USE_ITEM     |
45      use std::task::Context;
        |USE|USE_ITEM        |
46      use std::task::Poll;
        |USE|USE_ITEM     |
48      type PendingOpFuture = Pin<Box<dyn Future<Output = (OpId, Box<[u8]>)>>>;
        |TYPE_ALIAS          |assign
50      pub enum Snapshot {
            |ENUM         |enum{
51        Static(&'static [u8]),
          |ENUM_ITEM
                |tuple(
                 |t_elem      |)tuple
52        JustCreated(v8::StartupData),
          |ENUM_ITEM||tuple(
                      |T_ELEM        |)tuple
53        Boxed(Box<[u8]>),
          |ENUM_ITEM
               |tuple(
                |T_ELEM  |)tuple
54      }
        |}enum
56      pub type JsErrorCreateFn = dyn Fn(JsError) -> AnyError;
            |TYPE_ALIAS          |assign
58      pub type GetErrorClassFn =
            |TYPE_ALIAS          |assign
62      #[derive(Default)]
        |OUTER_ATTR      |
63      struct IsolateAllocations {
        |STRUCT                   |struct{
64        near_heap_limit_callback_data:
          |FIELD                      |
66      }
        |}struct
78      pub struct JsRuntime {
            |STRUCT          |struct{
81        v8_isolate: Option<v8::OwnedIsolate>,
          |FIELD   |
82        snapshot_creator: Option<v8::SnapshotCreator>,
          |FIELD         |
83        has_snapshotted: bool,
          |FIELD        |
84        needs_init: bool,
          |FIELD   |
85        allocations: IsolateAllocations,
          |FIELD    |
86      }
        |}struct
88      struct DynImportModEvaluate {
        |STRUCT                     |struct{
89        module_id: ModuleId,
          |FIELD  |
90        promise: v8::Global<v8::Promise>,
          |FIELD|
91        module: v8::Global<v8::Module>,
          |FIELD
92      }
        |}struct
94      struct ModEvaluate {
        |STRUCT            |struct{
95        promise: v8::Global<v8::Promise>,
          |FIELD|
96        sender: mpsc::Sender<Result<(), AnyError>>,
          |FIELD
97      }
        |}struct
101     pub(crate) struct JsRuntimeState {
                   |STRUCT               |struct{
102       pub global_context: Option<v8::Global<v8::Context>>,
          |FIELD
103       pub(crate) shared_ab: Option<v8::Global<v8::SharedArrayBuffer>>,
          |FIELD
             |struct{
                   |}struct
104       pub(crate) js_recv_cb: Option<v8::Global<v8::Function>>,
          |FIELD
             |struct{
                   |}struct
105       pub(crate) js_macrotask_cb: Option<v8::Global<v8::Function>>,
          |FIELD
             |struct{
                   |}struct
106       pub(crate) pending_promise_exceptions:
          |FIELD
             |struct{
                   |}struct
108       pending_dyn_mod_evaluate: HashMap<ModuleLoadId, DynImportModEvaluate>,
          |FIELD                 |
109       pending_mod_evaluate: Option<ModEvaluate>,
          |FIELD             |
110       pub(crate) js_error_create_fn: Rc<JsErrorCreateFn>,
          |FIELD
             |struct{
                   |}struct
111       pub(crate) shared: SharedQueue,
          |FIELD
             |struct{
                   |}struct
112       pub(crate) pending_ops: FuturesUnordered<PendingOpFuture>,
          |FIELD
             |struct{
                   |}struct
113       pub(crate) pending_unref_ops: FuturesUnordered<PendingOpFuture>,
          |FIELD
             |struct{
                   |}struct
114       pub(crate) have_unpolled_ops: Cell<bool>,
          |FIELD
             |struct{
                   |}struct
116       pub(crate) op_state: Rc<RefCell<OpState>>,
          |FIELD
             |struct{
                   |}struct
117       pub loader: Rc<dyn ModuleLoader>,
          |FIELD
118       pub modules: Modules,
          |FIELD
119       pub(crate) dyn_import_map:
          |FIELD
             |struct{
                   |}struct
121       preparing_dyn_imports: FuturesUnordered<Pin<Box<PrepareLoadFuture>>>,
          |FIELD              |
122       pending_dyn_imports: FuturesUnordered<StreamFuture<RecursiveModuleLoad>>,
          |FIELD            |
123       waker: AtomicWaker,
          |FIELD
124     }
        |}struct
126     impl Drop for JsRuntime {
        |IMPL                   |impl{
127       fn drop(&mut self) {
          |FUNCTION
                  |PARAM  |  |func{
128         if let Some(creator) = self.snapshot_creator.take() {
            |IF|VAR_DECL
                   |STRUCT()
                        |ARG  |  |assign                     |apply
                                                                |if{
133           let v8_isolate = self.v8_isolate.take().unwrap();
              |VAR_DECL      |assign               |apply   |apply
134           forget(v8_isolate);
                    |apply
                     |ARG     |
141           if self.has_snapshotted {
              |IF                     |if{
142             drop(creator);
                    |apply
                     |ARG  |
143           }
              |}if
144         }
            |}if
145       }
          |}func
146     }
        |}impl
148     #[allow(clippy::missing_safety_doc)]
        |OUTER_ATTR                        |
149     pub unsafe fn v8_init() {
                   |FUNCTION    |func{
150       let platform = v8::new_default_platform().unwrap();
          |VAR_DECL    |assign                   |apply   |apply
151       v8::V8::initialize_platform(platform);
                                     |apply
                                      |ARG   |
152       v8::V8::initialize();
                            |apply
157       let argv = vec![
          |VAR_DECL|assign
                     |MACRO()
                         |macro(){
162       ];
          |}macro()
163       v8::V8::set_flags_from_command_line(argv);
                                             |apply
                                              |ARG
164     }
        |}func
166     #[derive(Default)]
        |OUTER_ATTR      |
167     pub struct RuntimeOptions {
            |STRUCT               |struct{
171       pub js_error_create_fn: Option<Rc<JsErrorCreateFn>>,
          |FIELD
175       pub get_error_class_fn: Option<GetErrorClassFn>,
          |FIELD
182       pub module_loader: Option<Rc<dyn ModuleLoader>>,
          |FIELD
187       pub startup_snapshot: Option<Snapshot>,
          |FIELD
192       pub will_snapshot: bool,
          |FIELD
195       pub create_params: Option<v8::CreateParams>,
          |FIELD
196     }
        |}struct
198     impl JsRuntime {
        |IMPL          |impl{
200       pub fn new(mut options: RuntimeOptions) -> Self {
              |FUNCTION
                     |PARAM                    |          |func{
201         static DENO_INIT: Once = Once::new();
            |VAR_DECL              |assign    |apply
202         DENO_INIT.call_once(|| {
                               |apply
                                |ARG
                                |CLOSURE
                                   |closure{
                                   |return
                                   |inner{
203           unsafe { v8_init() };
                     |inner{  |apply
                                 |}inner
204         });
            |}inner
            |}closure
206         let global_context;
            |VAR_DECL
207         let (mut isolate, maybe_snapshot_creator) = if options.will_snapshot {
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM              ||)tuple
                                                      |assign
                                                        |IF                      |if{
209           assert!(options.startup_snapshot.is_none());
              |MACRO()
                     |macro(){                          |}macro()
210           let mut creator =
              |VAR_DECL       |assign
211             v8::SnapshotCreator::new(Some(&bindings::EXTERNAL_REFERENCES));
                                        |apply
                                         |ARG                               |
                                             |apply
                                              |ARG                         |
212           let isolate = unsafe { creator.get_owned_isolate() };
              |VAR_DECL   |assign  |inner{                    |apply
                                                                 |}inner
213           let mut isolate = JsRuntime::setup_isolate(isolate);
              |VAR_DECL       |assign                   |apply
                                                         |ARG  |
214           {
              |inner{
215             let scope = &mut v8::HandleScope::new(&mut isolate);
                |VAR_DECL |assign                    |apply
                                                      |ARG       |
216             let context = bindings::initialize_context(scope);
                |VAR_DECL   |assign                       |apply
                                                           |ARG|
217             global_context = v8::Global::new(scope, context);
                               |assign          |apply
                                                 |ARG|  |ARG  |
218             creator.set_default_context(context);
                                           |apply
                                            |ARG  |
219           }
              |}inner
220           (isolate, Some(creator))
              |tuple(
               |T_ELEM  |T_ELEM
                            |apply
                             |ARG  | |)tuple
221         } else {
            |}if
              |ELSE|else{
222           let mut params = options
              |VAR_DECL      |assign
224             .take()
                     |apply
225             .unwrap_or_else(v8::Isolate::create_params)
                               |apply
                                |ARG                     |
226             .external_references(&**bindings::EXTERNAL_REFERENCES);
                                    |apply
                                     |ARG                           |
227           let snapshot_loaded = if let Some(snapshot) = options.startup_snapshot {
              |VAR_DECL           |assign
                                    |IF|VAR_DECL
                                           |STRUCT()
                                                |ARG   |  |assign                    |if{
228             params = match snapshot {
                       |assign
                         |MATCH         |match{
229               Snapshot::Static(data) => params.snapshot_blob(data),
                  |CASE  |
                  |STRUCT()        |ARG                         |apply
                                                                 |ARG
230               Snapshot::JustCreated(data) => params.snapshot_blob(data),
                  |CASE  |
                  |STRUCT()             |ARG                         |apply
                                                                      |ARG
231               Snapshot::Boxed(data) => params.snapshot_blob(data),
                  |CASE  |
                  |STRUCT()       |ARG                         |apply
                                                                |ARG
232             };
                |}match
234           } else {
              |}if
                |ELSE|else{
236           };
              |else}
238           let isolate = v8::Isolate::new(params);
              |VAR_DECL   |assign           |apply
                                             |ARG |
239           let mut isolate = JsRuntime::setup_isolate(isolate);
              |VAR_DECL       |assign                   |apply
                                                         |ARG  |
240           {
              |inner{
241             let scope = &mut v8::HandleScope::new(&mut isolate);
                |VAR_DECL |assign                    |apply
                                                      |ARG       |
242             let context = if snapshot_loaded {
                |VAR_DECL   |assign
                              |IF                |if{
243               v8::Context::new(scope)
                                  |apply
                                   |ARG|
244             } else {
                |}if
                  |ELSE|else{
247               bindings::initialize_context(scope)
                                              |apply
                                               |ARG|
248             };
                |else}
249             global_context = v8::Global::new(scope, context);
                               |assign          |apply
                                                 |ARG|  |ARG  |
250           }
              |}inner
251           (isolate, None)
              |tuple(
               |T_ELEM  |T_ELEM
                            |)tuple
252         };
            |else}
254         let loader = options
            |VAR_DECL  |assign
256           .unwrap_or_else(|| Rc::new(NoopModuleLoader));
                             |apply
                              |ARG                       |
                              |CLOSURE
                                 |CLOSURE{
                                 |RETURN|apply
                                         |ARG           ||}closure
258         let js_error_create_fn = options
            |VAR_DECL              |assign
260           .unwrap_or_else(|| Rc::new(JsError::create));
                             |apply
                              |ARG                      |
                              |CLOSURE
                                 |CLOSURE{
                                 |RETURN|apply
                                         |ARG          ||}closure
261         let mut op_state = OpState::default();
            |VAR_DECL        |assign           |apply
263         if let Some(get_error_class_fn) = options.get_error_class_fn {
            |IF|VAR_DECL
                   |STRUCT()
                        |ARG             |  |assign                      |if{
264           op_state.get_error_class_fn = get_error_class_fn;
                                          |assign
265         }
            |}if
267         isolate.set_slot(Rc::new(RefCell::new(JsRuntimeState {
                            |apply
                             |ARG
                                    |apply
                                     |ARG
                                                 |apply
                                                  |ARG
                                                  |STRUCT()    |
268           global_context: Some(global_context),
              |ARG                               |
                                  |apply
                                   |ARG         |
269           pending_promise_exceptions: HashMap::new(),
              |ARG                                     |
                                                      |apply
270           pending_dyn_mod_evaluate: HashMap::new(),
              |ARG                                   |
                                                    |apply
271           pending_mod_evaluate: None,
              |ARG                     |
272           shared_ab: None,
              |ARG          |
273           js_recv_cb: None,
              |ARG           |
274           js_macrotask_cb: None,
              |ARG                |
275           js_error_create_fn,
              |ARG             |
276           shared: SharedQueue::new(RECOMMENDED_SIZE),
              |ARG                                     |
                                      |apply
                                       |ARG           |
277           pending_ops: FuturesUnordered::new(),
              |ARG                               |
                                                |apply
278           pending_unref_ops: FuturesUnordered::new(),
              |ARG                                     |
                                                      |apply
279           op_state: Rc::new(RefCell::new(op_state)),
              |ARG                                    |
                               |apply
                                |ARG                 |
                                            |apply
                                             |ARG   |
280           have_unpolled_ops: Cell::new(false),
              |ARG                              |
                                          |apply
                                           |ARG|
281           modules: Modules::new(),
              |ARG                  |
                                   |apply
282           loader,
              |ARG |
283           dyn_import_map: HashMap::new(),
              |ARG                         |
                                          |apply
284           preparing_dyn_imports: FuturesUnordered::new(),
              |ARG                                         |
                                                          |apply
285           pending_dyn_imports: FuturesUnordered::new(),
              |ARG                                       |
                                                        |apply
286           waker: AtomicWaker::new(),
              |ARG                    |
                                     |apply
289         Self {
            |STRUCT()
290           v8_isolate: Some(isolate),
              |ARG                    |
                              |apply
                               |ARG  |
291           snapshot_creator: maybe_snapshot_creator,
              |ARG                                   |
292           has_snapshotted: false,
              |ARG                 |
293           needs_init: true,
              |ARG           |
294           allocations: IsolateAllocations::default(),
              |ARG                                     |
                                                      |apply
296       }
          |}func
298       pub fn global_context(&mut self) -> v8::Global<v8::Context> {
              |FUNCTION         |PARAM  |                             |func{
299         let state = Self::state(self.v8_isolate());
            |VAR_DECL |assign      |apply
                                    |ARG            |
                                                   |apply
300         let state = state.borrow();
            |VAR_DECL |assign       |apply
301         state.global_context.clone().unwrap()
                                      |apply   |apply
302       }
          |}func
304       pub fn v8_isolate(&mut self) -> &mut v8::OwnedIsolate {
              |FUNCTION     |PARAM  |                           |func{
305         self.v8_isolate.as_mut().unwrap()
                                  |apply   |apply
306       }
          |}func
308       fn setup_isolate(mut isolate: v8::OwnedIsolate) -> v8::OwnedIsolate {
          |FUNCTION        |PARAM                      |                      |func{
309         isolate.set_capture_stack_trace_for_uncaught_exceptions(true, 10);
                                                                   |apply
                                                                    |ARG  |ARG
310         isolate.set_promise_reject_callback(bindings::promise_reject_callback);
                                               |apply
                                                |ARG                            |
311         isolate.set_host_initialize_import_meta_object_callback(
                                                                   |apply
312           bindings::host_initialize_import_meta_object_callback,
              |ARG                                                |
314         isolate.set_host_import_module_dynamically_callback(
                                                               |apply
315           bindings::host_import_module_dynamically_callback,
              |ARG                                            |
318       }
          |}func
320       pub(crate) fn state(isolate: &v8::Isolate) -> Rc<RefCell<JsRuntimeState>> {
                     |FUNCTION|PARAM              |                                 |func{
321         let s = isolate.get_slot::<Rc<RefCell<JsRuntimeState>>>().unwrap();
            |VAR_DECL
                  |assign              |T_ARG                    | |apply   |apply
322         s.clone()
                   |apply
323       }
          |}func
326       fn shared_init(&mut self) {
          |FUNCTION      |PARAM  |  |func{
327         if self.needs_init {
            |IF                |if{
328           self.needs_init = false;
                              |assign
330             .execute("deno:core/core.js", include_str!("core.js"))
                        |apply
                         |ARG              |  |ARG                  |
                                              |MACRO()  | |macro(){ |}macro()
331             .unwrap();
                       |apply
333             .execute("deno:core/error.js", include_str!("error.js"))
                        |apply
                         |ARG               |  |ARG                   |
                                               |MACRO()  | |macro(){  |}macro()
334             .unwrap();
                       |apply
335         }
            |}if
336       }
          |}func
340       pub fn op_state(&mut self) -> Rc<RefCell<OpState>> {
              |FUNCTION   |PARAM  |                          |func{
341         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
342         let state = state_rc.borrow();
            |VAR_DECL |assign          |apply
343         state.op_state.clone()
                                |apply
344       }
          |}func
354       pub fn execute(
              |FUNCTION
355         &mut self,
            |PARAM  |
356         js_filename: &str,
            |PARAM          |
357         js_source: &str,
            |PARAM        |
358       ) -> Result<(), AnyError> {
                                    |func{
359         self.shared_init();
                            |apply
361         let context = self.global_context();
            |VAR_DECL   |assign              |apply
363         let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |
365         let source = v8::String::new(scope, js_source).unwrap();
            |VAR_DECL  |assign          |apply
                                         |ARG|  |ARG    |        |apply
366         let name = v8::String::new(scope, js_filename).unwrap();
            |VAR_DECL|assign          |apply
                                       |ARG|  |ARG      |        |apply
367         let origin = bindings::script_origin(scope, name);
            |VAR_DECL  |assign                  |apply
                                                 |ARG|  |ARG
369         let tc_scope = &mut v8::TryCatch::new(scope);
            |VAR_DECL    |assign                 |apply
                                                  |ARG|
371         let script = match v8::Script::compile(tc_scope, source, Some(&origin)) {
            |VAR_DECL  |assign
                         |MATCH                   |apply
                                                   |ARG   |  |ARG |  |ARG        |
                                                                         |apply
                                                                          |ARG  |   |match{
372           Some(script) => script,
              |CASE
              |STRUCT()
                   |ARG |
373           None => {
              |CASE   |inner{
374             let exception = tc_scope.exception().unwrap();
                |VAR_DECL     |assign             |apply   |apply
375             return exception_to_err_result(tc_scope, exception, false);
                |RETURN                       |apply
                                               |ARG   |  |ARG    |  |ARG|
376           }
              |}inner
377         };
            |}match
379         match script.run(tc_scope) {
            |MATCH          |apply
                             |ARG   |  |match{
380           Some(_) => Ok(()),
              |CASE
              |STRUCT()
                   |arg    |apply
                            |ARG
                            |tuple(
                             |)tuple
381           None => {
              |CASE   |inner{
382             assert!(tc_scope.has_caught());
                |MACRO()
                       |macro(){             |}macro()
383             let exception = tc_scope.exception().unwrap();
                |VAR_DECL     |assign             |apply   |apply
384             exception_to_err_result(tc_scope, exception, false)
                                       |apply
                                        |ARG   |  |ARG    |  |ARG|
385           }
              |}inner
386         }
            |}match
387       }
          |}func
395       pub fn snapshot(&mut self) -> v8::StartupData {
              |FUNCTION   |PARAM  |                     |func{
396         assert!(self.snapshot_creator.is_some());
            |MACRO()
                   |macro(){                       |}macro()
397         let state = Self::state(self.v8_isolate());
            |VAR_DECL |assign      |apply
                                    |ARG            |
                                                   |apply
401         state.borrow_mut().global_context.take();
                            |apply                |apply
403         std::mem::take(&mut state.borrow_mut().modules);
                          |apply
                           |ARG                          |
                                                |apply
405         let snapshot_creator = self.snapshot_creator.as_mut().unwrap();
            |VAR_DECL            |assign                       |apply   |apply
406         let snapshot = snapshot_creator
            |VAR_DECL    |assign
407           .create_blob(v8::FunctionCodeHandling::Keep)
                          |apply
                           |ARG                         |
408           .unwrap();
                     |apply
409         self.has_snapshotted = true;
                                 |assign
412       }
          |}func
423       pub fn register_op<F>(&mut self, name: &str, op_fn: F) -> OpId
              |FUNCTION      |<t>
                                |PARAM  |  |PARAM   |  |PARAM |
426       {
          |func{
427         Self::state(self.v8_isolate())
                       |apply
                        |ARG            |
                                       |apply
428           .borrow_mut()
                         |apply
430           .borrow_mut()
                         |apply
432           .register_op(name, op_fn)
                          |apply
                           |ARG  |ARG|
433       }
          |}func
440       pub fn add_near_heap_limit_callback<C>(&mut self, cb: C)
              |FUNCTION                       |<t>
                                                 |PARAM  |  |PARAM
443       {
          |func{
444         let boxed_cb = Box::new(RefCell::new(cb));
            |VAR_DECL    |assign   |apply
                                    |ARG           |
                                                |apply
                                                 |ARG
445         let data = boxed_cb.as_ptr() as *mut c_void;
            |VAR_DECL|assign          |apply
447         let prev = self
            |VAR_DECL|assign
450           .replace((boxed_cb, near_heap_limit_callback::<C>));
                      |apply
                       |ARG                                    |
                       |tuple(
                        |T_ELEM|  |T_ELEM                |   |t_arg
                                                               |)tuple
451         if let Some((_, prev_cb)) = prev {
            |IF|VAR_DECL
                   |STRUCT()
                        |ARG       |
                        |tuple
                        |tuple(
                         |t_elem
                            |T_ELEM|)tuple
                                      |assign|if{
453             .v8_isolate()
                           |apply
454             .remove_near_heap_limit_callback(prev_cb, 0);
                                                |apply
                                                 |ARG  |  |arg
455         }
            |}if
458           .v8_isolate()
                         |apply
459           .add_near_heap_limit_callback(near_heap_limit_callback::<C>, data);
                                           |apply
                                            |ARG                        |
                                                                       |t_arg
                                                                           |ARG
460       }
          |}func
462       pub fn remove_near_heap_limit_callback(&mut self, heap_limit: usize) {
              |FUNCTION                          |PARAM  |  |PARAM          |  |func{
463         if let Some((_, cb)) = self.allocations.near_heap_limit_callback_data.take()
            |IF|VAR_DECL
                   |STRUCT()
                        |ARG  |
                        |tuple
                        |tuple(
                         |t_elem
                            |T_ELEM
                              |)tuple
                                 |assign                                              |apply
464         {
            |if{
466             .v8_isolate()
                           |apply
467             .remove_near_heap_limit_callback(cb, heap_limit);
                                                |apply
                                                 |ARG|ARG     |
468         }
            |}if
469       }
          |}func
476       pub async fn run_event_loop(&mut self) -> Result<(), AnyError> {
                    |FUNCTION         |PARAM  |                          |func{
477         poll_fn(|cx| self.poll_event_loop(cx)).await
                   |apply
                    |ARG                        |
                    |closure
                     |PARAM
                         |CLOSURE{
                         |RETURN             |apply
                                              |ARG
                                                |}closure
478       }
          |}func
481       pub fn poll_event_loop(
              |FUNCTION
482         &mut self,
            |PARAM  |
483         cx: &mut Context,
            |PARAM         |
484       ) -> Poll<Result<(), AnyError>> {
                                          |func{
485         self.shared_init();
                            |apply
487         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
488         {
            |inner{
489           let state = state_rc.borrow();
              |VAR_DECL |assign          |apply
490           state.waker.register(cx.waker());
                                  |apply
                                   |ARG     |
                                           |apply
491         }
            |}inner
494         {
            |inner{
495           let overflow_response = self.poll_pending_ops(cx);
              |VAR_DECL             |assign                |apply
                                                            |ARG
496           self.async_op_response(overflow_response)?;
                                    |apply
                                     |ARG            |
497           self.drain_macrotasks()?;
                                   |apply
498           self.check_promise_exceptions()?;
                                           |apply
499         }
            |}inner
502         {
            |inner{
503           let poll_imports = self.prepare_dyn_imports(cx)?;
              |VAR_DECL        |assign                   |apply
                                                          |ARG
504           assert!(poll_imports.is_ready());
              |MACRO()
                     |macro(){               |}macro()
506           let poll_imports = self.poll_dyn_imports(cx)?;
              |VAR_DECL        |assign                |apply
                                                       |ARG
507           assert!(poll_imports.is_ready());
              |MACRO()
                     |macro(){               |}macro()
509           self.evaluate_dyn_imports();
                                       |apply
511           self.check_promise_exceptions()?;
                                           |apply
512         }
            |}inner
515         self.evaluate_pending_module();
                                        |apply
517         let state = state_rc.borrow();
            |VAR_DECL |assign          |apply
518         let has_pending_ops = !state.pending_ops.is_empty();
            |VAR_DECL           |assign                      |apply
520         let has_pending_dyn_imports = !{
            |VAR_DECL                   |assign
                                           |inner{
521           state.preparing_dyn_imports.is_empty()
                                                  |apply
522             && state.pending_dyn_imports.is_empty()
                                                     |apply
523         };
            |}inner
524         let has_pending_dyn_module_evaluation =
            |VAR_DECL                             |assign
525           !state.pending_dyn_mod_evaluate.is_empty();
                                                      |apply
526         let has_pending_module_evaluation = state.pending_mod_evaluate.is_some();
            |VAR_DECL                         |assign                             |apply
528         if !has_pending_ops
            |IF
532         {
            |if{
533           return Poll::Ready(Ok(()));
              |RETURN           |apply
                                 |ARG |
                                   |apply
                                    |ARG
                                    |tuple(
                                     |)tuple
534         }
            |}if
538         if state.have_unpolled_ops.get() {
            |IF                           |apply
                                             |if{
539           state.waker.wake();
                              |apply
540         }
            |}if
542         if has_pending_module_evaluation {
            |IF                              |if{
543           if has_pending_ops
              |IF
546           {
              |if{
548           } else {
              |}if
                |ELSE|else{
549             let msg = "Module evaluation is still pending but there are no pending ops or dynamic imports. This situation is often caused by unresolved promise.";
                |VAR_DECL
                        |assign
550             return Poll::Ready(Err(generic_error(msg)));
                |RETURN           |apply
                                   |ARG                  |
                                      |apply
                                       |ARG             |
                                                    |apply
                                                     |ARG
551           }
              |else}
552         }
            |}if
554         if has_pending_dyn_module_evaluation {
            |IF                                  |if{
555           if has_pending_ops || has_pending_dyn_imports {
              |IF                                           |if{
557           } else {
              |}if
                |ELSE|else{
558             let msg = "Dynamically imported module evaluation is still pending but there are no pending ops. This situation is often caused by unresolved promise.";
                |VAR_DECL
                        |assign
559             return Poll::Ready(Err(generic_error(msg)));
                |RETURN           |apply
                                   |ARG                  |
                                      |apply
                                       |ARG             |
                                                    |apply
                                                     |ARG
560           }
              |else}
561         }
            |}if
564       }
          |}func
565     }
        |}impl
567     extern "C" fn near_heap_limit_callback<F>(
                   |FUNCTION                   |<t>
568       data: *mut c_void,
          |PARAM          |
569       current_heap_limit: usize,
          |PARAM                  |
570       initial_heap_limit: usize,
          |PARAM                  |
574     {
        |func{
575       let callback = unsafe { &mut *(data as *mut F) };
          |VAR_DECL    |assign  |inner{                  |}inner
576       callback(current_heap_limit, initial_heap_limit)
                  |apply
                   |ARG             |  |ARG             |
577     }
        |}func
579     impl JsRuntimeState {
        |IMPL               |impl{
581       pub fn dyn_import_cb(
              |FUNCTION
582         &mut self,
            |PARAM  |
583         resolver_handle: v8::Global<v8::PromiseResolver>,
            |PARAM                                         |
584         specifier: &str,
            |PARAM        |
585         referrer: &str,
            |PARAM       |
586       ) {
            |func{
587         debug!("dyn_import specifier {} referrer {} ", specifier, referrer);
            |MACRO()
                  |macro(){                                                   |}macro()
589         let load = RecursiveModuleLoad::dynamic_import(
            |VAR_DECL|assign                              |apply
590           self.op_state.clone(),
              |ARG                |
                                 |apply
591           specifier,
              |ARG    |
592           referrer,
              |ARG   |
593           self.loader.clone(),
              |ARG              |
                               |apply
595         self.dyn_import_map.insert(load.id, resolver_handle);
                                      |apply
                                       |ARG  |  |ARG          |
596         self.waker.wake();
                           |apply
597         let fut = load.prepare().boxed_local();
            |VAR_DECL
                    |assign       |apply        |apply
598         self.preparing_dyn_imports.push(fut);
                                           |apply
                                            |ARG
599       }
          |}func
600     }
        |}impl
602     pub(crate) fn exception_to_err_result<'s, T>(
                   |FUNCTION                  |<T>|<t>
603       scope: &mut v8::HandleScope<'s>,
          |PARAM                        |
604       exception: v8::Local<v8::Value>,
          |PARAM                        |
605       in_promise: bool,
          |PARAM         |
606     ) -> Result<T, AnyError> {
                                 |func{
609       let is_terminating_exception =
          |VAR_DECL                    |assign
610         scope.thread_safe_handle().is_execution_terminating();
                                    |apply                     |apply
611       let mut exception = exception;
          |VAR_DECL         |assign
613       if is_terminating_exception {
          |IF                         |if{
618         scope.thread_safe_handle().cancel_terminate_execution();
                                    |apply                       |apply
621         if exception.is_null_or_undefined() {
            |IF                              |apply
                                                |if{
622           let message = v8::String::new(scope, "execution terminated").unwrap();
              |VAR_DECL   |assign          |apply
                                            |ARG|  |ARG                 |        |apply
623           exception = v8::Exception::error(scope, message);
                        |assign               |apply
                                               |ARG|  |ARG  |
624         }
            |}if
625       }
          |}if
627       let mut js_error = JsError::from_v8_exception(scope, exception);
          |VAR_DECL        |assign                     |apply
                                                        |ARG|  |ARG    |
628       if in_promise {
          |IF           |if{
629         js_error.message = format!(
                             |assign
                               |MACRO()
                                      |macro(){
632         );
            |}macro()
633       }
          |}if
635       let state_rc = JsRuntime::state(scope);
          |VAR_DECL    |assign           |apply
                                          |ARG|
636       let state = state_rc.borrow();
          |VAR_DECL |assign          |apply
637       let js_error = (state.js_error_create_fn)(js_error);
          |VAR_DECL    |assign
                         |apply                    |apply
                                                    |ARG   |
639       if is_terminating_exception {
          |IF                         |if{
643         scope.thread_safe_handle().terminate_execution();
                                    |apply                |apply
644       }
          |}if
646       Err(js_error)
             |apply
              |ARG   |
647     }
        |}func
650     impl JsRuntime {
        |IMPL          |impl{
654       fn mod_new(
          |FUNCTION
655         &mut self,
            |PARAM  |
656         main: bool,
            |PARAM   |
657         name: &str,
            |PARAM   |
658         source: &str,
            |PARAM     |
659       ) -> Result<ModuleId, AnyError> {
                                          |func{
660         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
661         let context = self.global_context();
            |VAR_DECL   |assign              |apply
662         let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |
664         let name_str = v8::String::new(scope, name).unwrap();
            |VAR_DECL    |assign          |apply
                                           |ARG|  |ARG        |apply
665         let source_str = v8::String::new(scope, source).unwrap();
            |VAR_DECL      |assign          |apply
                                             |ARG|  |ARG |        |apply
667         let origin = bindings::module_origin(scope, name_str);
            |VAR_DECL  |assign                  |apply
                                                 |ARG|  |ARG   |
668         let source = v8::script_compiler::Source::new(source_str, &origin);
            |VAR_DECL  |assign                           |apply
                                                          |ARG     |  |ARG  |
670         let tc_scope = &mut v8::TryCatch::new(scope);
            |VAR_DECL    |assign                 |apply
                                                  |ARG|
672         let maybe_module = v8::script_compiler::compile_module(tc_scope, source);
            |VAR_DECL        |assign                              |apply
                                                                   |ARG   |  |ARG |
674         if tc_scope.has_caught() {
            |IF                   |apply
                                     |if{
675           assert!(maybe_module.is_none());
              |MACRO()
                     |macro(){              |}macro()
676           let e = tc_scope.exception().unwrap();
              |VAR_DECL
                    |assign             |apply   |apply
677           return exception_to_err_result(tc_scope, e, false);
              |RETURN                       |apply
                                             |ARG   |  |arg
                                                          |ARG|
678         }
            |}if
680         let module = maybe_module.unwrap();
            |VAR_DECL  |assign              |apply
682         let mut import_specifiers: Vec<ModuleSpecifier> = vec![];
            |VAR_DECL                                       |assign
                                                              |MACRO()
                                                                  |macro(){
                                                                   |}macro()
683         for i in 0..module.get_module_requests_length() {
            |FOR                                         |apply
                                                            |for{
684           let import_specifier =
              |VAR_DECL            |assign
685             module.get_module_request(i).to_rust_string_lossy(tc_scope);
                                         |apply
                                          |arg                   |apply
                                                                  |ARG   |
686           let state = state_rc.borrow();
              |VAR_DECL |assign          |apply
687           let module_specifier = state.loader.resolve(
              |VAR_DECL            |assign               |apply
688             state.op_state.clone(),
                |ARG                 |
                                    |apply
689             &import_specifier,
                |ARG            |
690             name,
                |ARG
691             false,
                |ARG|
693           import_specifiers.push(module_specifier);
                                    |apply
                                     |ARG           |
694         }
            |}for
696         let id = state_rc.borrow_mut().modules.register(
            |VAR_DECL
                   |assign              |apply             |apply
697           name,
              |ARG
698           main,
              |ARG
699           v8::Global::<v8::Module>::new(tc_scope, module),
              |ARG                                          |
                           |T_ARG   |      |apply
                                            |ARG   |  |ARG |
700           import_specifiers,
              |ARG            |
703         Ok(id)
              |apply
               |ARG
704       }
          |}func
711       fn mod_instantiate(&mut self, id: ModuleId) -> Result<(), AnyError> {
          |FUNCTION          |PARAM  |  |PARAM     |                          |func{
712         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
713         let context = self.global_context();
            |VAR_DECL   |assign              |apply
715         let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |
716         let tc_scope = &mut v8::TryCatch::new(scope);
            |VAR_DECL    |assign                 |apply
                                                  |ARG|
718         let module = state_rc
            |VAR_DECL  |assign
719           .borrow()
                     |apply
721           .get_handle(id)
                         |apply
                          |ARG
722           .map(|handle| v8::Local::new(tc_scope, handle))
                  |apply
                   |ARG                                    |
                   |closure
                    |PARAM  |CLOSURE{
                            |RETURN       |apply
                                           |ARG   |  |ARG ||}closure
723           .expect("ModuleInfo not found");
                     |apply
                      |ARG                 |
725         if module.get_status() == v8::ModuleStatus::Errored {
            |IF                 |apply                          |if{
726           exception_to_err_result(tc_scope, module.get_exception(), false)?
                                     |apply
                                      |ARG   |  |ARG                 |
                                                                    |apply
                                                                        |ARG|
727         }
            |}if
729         let result =
            |VAR_DECL  |assign
730           module.instantiate_module(tc_scope, bindings::module_resolve_callback);
                                       |apply
                                        |ARG   |  |ARG                            |
731         match result {
            |MATCH       |match{
732           Some(_) => Ok(()),
              |CASE
              |STRUCT()
                   |arg    |apply
                            |ARG
                            |tuple(
                             |)tuple
733           None => {
              |CASE   |inner{
734             let exception = tc_scope.exception().unwrap();
                |VAR_DECL     |assign             |apply   |apply
735             exception_to_err_result(tc_scope, exception, false)
                                       |apply
                                        |ARG   |  |ARG    |  |ARG|
736           }
              |}inner
737         }
            |}match
738       }
          |}func
745       pub fn dyn_mod_evaluate(
              |FUNCTION
746         &mut self,
            |PARAM  |
747         load_id: ModuleLoadId,
            |PARAM              |
748         id: ModuleId,
            |PARAM     |
749       ) -> Result<(), AnyError> {
                                    |func{
750         self.shared_init();
                            |apply
752         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
753         let context = self.global_context();
            |VAR_DECL   |assign              |apply
754         let context1 = self.global_context();
            |VAR_DECL    |assign              |apply
756         let module_handle = state_rc
            |VAR_DECL         |assign
757           .borrow()
                     |apply
759           .get_handle(id)
                         |apply
                          |ARG
760           .expect("ModuleInfo not found");
                     |apply
                      |ARG                 |
762         let status = {
            |VAR_DECL  |assign
                         |inner{
763           let scope =
              |VAR_DECL |assign
764             &mut v8::HandleScope::with_context(self.v8_isolate(), context);
                                                  |apply
                                                   |ARG            |
                                                                  |apply
                                                                      |ARG  |
765           let module = module_handle.get(scope);
              |VAR_DECL  |assign            |apply
                                             |ARG|
766           module.get_status()
                               |apply
767         };
            |}inner
769         if status == v8::ModuleStatus::Instantiated {
            |IF                                         |if{
786           let scope =
              |VAR_DECL |assign
787             &mut v8::HandleScope::with_context(self.v8_isolate(), context1);
                                                  |apply
                                                   |ARG            |
                                                                  |apply
                                                                      |ARG   |
788           let module = v8::Local::new(scope, &module_handle);
              |VAR_DECL  |assign         |apply
                                          |ARG|  |ARG         |
789           let maybe_value = module.evaluate(scope);
              |VAR_DECL       |assign          |apply
                                                |ARG|
792           let status = module.get_status();
              |VAR_DECL  |assign            |apply
794           if let Some(value) = maybe_value {
              |IF|VAR_DECL
                     |STRUCT()
                          |ARG|  |assign       |if{
795             assert!(
                |MACRO()
                       |macro(){
798             );
                |}macro()
799             let promise = v8::Local::<v8::Promise>::try_from(value)
                |VAR_DECL   |assign       |T_ARG    |           |apply
                                                                 |ARG|
800               .expect("Expected to get promise as module evaluation result");
                         |apply
                          |ARG                                                |
801             let promise_global = v8::Global::new(scope, promise);
                |VAR_DECL          |assign          |apply
                                                     |ARG|  |ARG  |
802             let mut state = state_rc.borrow_mut();
                |VAR_DECL     |assign              |apply
803             state.pending_promise_exceptions.remove(&promise_global);
                                                       |apply
                                                        |ARG          |
804             let promise_global = v8::Global::new(scope, promise);
                |VAR_DECL          |assign          |apply
                                                     |ARG|  |ARG  |
805             let module_global = v8::Global::new(scope, module);
                |VAR_DECL         |assign          |apply
                                                    |ARG|  |ARG |
807             let dyn_import_mod_evaluate = DynImportModEvaluate {
                |VAR_DECL                   |assign
                                              |STRUCT()          |
808               module_id: id,
                  |ARG        |
809               promise: promise_global,
                  |ARG                  |
810               module: module_global,
                  |ARG                |
815               .insert(load_id, dyn_import_mod_evaluate);
                         |apply
                          |ARG  |  |ARG                  |
816           } else {
              |}if
                |ELSE|else{
817             assert!(status == v8::ModuleStatus::Errored);
                |MACRO()
                       |macro(){                           |}macro()
818           }
              |else}
819         }
            |}if
821         if status == v8::ModuleStatus::Evaluated {
            |IF                                      |if{
822           self.dyn_import_done(load_id, id);
                                  |apply
                                   |ARG  |  |ARG
823         }
            |}if
825         Ok(())
              |apply
               |ARG
               |tuple(
                |)tuple
826       }
          |}func
833       fn mod_evaluate_inner(
          |FUNCTION
834         &mut self,
            |PARAM  |
835         id: ModuleId,
            |PARAM     |
836       ) -> mpsc::Receiver<Result<(), AnyError>> {
                                                    |func{
837         self.shared_init();
                            |apply
839         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
840         let context = self.global_context();
            |VAR_DECL   |assign              |apply
842         let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |
844         let module = state_rc
            |VAR_DECL  |assign
845           .borrow()
                     |apply
847           .get_handle(id)
                         |apply
                          |ARG
848           .map(|handle| v8::Local::new(scope, handle))
                  |apply
                   |ARG                                 |
                   |closure
                    |PARAM  |CLOSURE{
                            |RETURN       |apply
                                           |ARG|  |ARG ||}closure
849           .expect("ModuleInfo not found");
                     |apply
                      |ARG                 |
850         let mut status = module.get_status();
            |VAR_DECL      |assign            |apply
852         let (sender, receiver) = mpsc::channel(1);
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM |T_ELEM||)tuple
                                   |assign        |apply
                                                   |arg
854         if status == v8::ModuleStatus::Instantiated {
            |IF                                         |if{
871           let maybe_value = module.evaluate(scope);
              |VAR_DECL       |assign          |apply
                                                |ARG|
874           status = module.get_status();
                     |assign            |apply
876           if let Some(value) = maybe_value {
              |IF|VAR_DECL
                     |STRUCT()
                          |ARG|  |assign       |if{
877             assert!(
                |MACRO()
                       |macro(){
880             );
                |}macro()
881             let promise = v8::Local::<v8::Promise>::try_from(value)
                |VAR_DECL   |assign       |T_ARG    |           |apply
                                                                 |ARG|
882               .expect("Expected to get promise as module evaluation result");
                         |apply
                          |ARG                                                |
883             let promise_global = v8::Global::new(scope, promise);
                |VAR_DECL          |assign          |apply
                                                     |ARG|  |ARG  |
884             let mut state = state_rc.borrow_mut();
                |VAR_DECL     |assign              |apply
885             state.pending_promise_exceptions.remove(&promise_global);
                                                       |apply
                                                        |ARG          |
886             let promise_global = v8::Global::new(scope, promise);
                |VAR_DECL          |assign          |apply
                                                     |ARG|  |ARG  |
887             assert!(
                |MACRO()
                       |macro(){
890             );
                |}macro()
892             state.pending_mod_evaluate = Some(ModEvaluate {
                                           |assign
                                                 |apply
                                                  |ARG
                                                  |STRUCT() |
893               promise: promise_global,
                  |ARG                  |
894               sender,
                  |ARG |
896             scope.perform_microtask_checkpoint();
                                                  |apply
897           } else {
              |}if
                |ELSE|else{
898             assert!(status == v8::ModuleStatus::Errored);
                |MACRO()
                       |macro(){                           |}macro()
899           }
              |else}
900         }
            |}if
903       }
          |}func
905       pub async fn mod_evaluate(&mut self, id: ModuleId) -> Result<(), AnyError> {
                    |FUNCTION       |PARAM  |  |PARAM     |                          |func{
906         let mut receiver = self.mod_evaluate_inner(id);
            |VAR_DECL        |assign                  |apply
                                                       |ARG
908         poll_fn(|cx| {
                   |apply
                    |ARG
                    |closure
                     |PARAM
                         |closure{
                         |return
                         |inner{
909           if let Poll::Ready(maybe_result) = receiver.poll_next_unpin(cx) {
              |IF|VAR_DECL
                     |STRUCT()   |ARG       |  |assign                   |apply
                                                                          |ARG|if{
910             debug!("received module evaluate {:#?}", maybe_result);
                |MACRO()
                      |macro(){                                      |}macro()
914             let result = maybe_result.unwrap_or(Ok(()));
                |VAR_DECL  |assign                 |apply
                                                    |ARG |
                                                      |apply
                                                       |ARG
                                                       |tuple(
                                                        |)tuple
915             return Poll::Ready(result);
                |RETURN           |apply
                                   |ARG |
916           }
              |}if
917           let _r = self.poll_event_loop(cx)?;
              |VAR_DECL
                     |assign               |apply
                                            |ARG
919         })
            |}inner
            |}closure
921       }
          |}func
923       fn dyn_import_error(&mut self, id: ModuleLoadId, err: AnyError) {
          |FUNCTION           |PARAM  |  |PARAM         |  |PARAM      |  |func{
924         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
925         let context = self.global_context();
            |VAR_DECL   |assign              |apply
927         let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |
929         let resolver_handle = state_rc
            |VAR_DECL           |assign
930           .borrow_mut()
                         |apply
932           .remove(&id)
                     |apply
                      |ARG
933           .expect("Invalid dyn import id");
                     |apply
                      |ARG                  |
934         let resolver = resolver_handle.get(scope);
            |VAR_DECL    |assign              |apply
                                               |ARG|
936         let exception = err
            |VAR_DECL     |assign
937           .downcast_ref::<ErrWithV8Handle>()
                              |T_ARG        | |apply
938           .map(|err| err.get_handle(scope))
                  |apply
                   |ARG                      |
                   |closure
                    |PARAM
                         |CLOSURE{
                         |RETURN       |apply
                                        |ARG||}closure
939           .unwrap_or_else(|| {
                             |apply
                              |ARG
                              |CLOSURE
                                 |closure{
                                 |return
                                 |inner{
940             let message = err.to_string();
                |VAR_DECL   |assign        |apply
941             let message = v8::String::new(scope, &message).unwrap();
                |VAR_DECL   |assign          |apply
                                              |ARG|  |ARG   |        |apply
942             v8::Exception::type_error(scope, message)
                                         |apply
                                          |ARG|  |ARG  |
943           });
              |}inner
              |}closure
945         resolver.reject(scope, exception).unwrap();
                           |apply
                            |ARG|  |ARG    |        |apply
946         scope.perform_microtask_checkpoint();
                                              |apply
947       }
          |}func
949       fn dyn_import_done(&mut self, id: ModuleLoadId, mod_id: ModuleId) {
          |FUNCTION          |PARAM  |  |PARAM         |  |PARAM         |  |func{
950         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
951         let context = self.global_context();
            |VAR_DECL   |assign              |apply
953         debug!("dyn_import_done {} {:?}", id, mod_id);
            |MACRO()
                  |macro(){                             |}macro()
954         let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |
956         let resolver_handle = state_rc
            |VAR_DECL           |assign
957           .borrow_mut()
                         |apply
959           .remove(&id)
                     |apply
                      |ARG
960           .expect("Invalid dyn import id");
                     |apply
                      |ARG                  |
961         let resolver = resolver_handle.get(scope);
            |VAR_DECL    |assign              |apply
                                               |ARG|
963         let module = {
            |VAR_DECL  |assign
                         |inner{
964           let state = state_rc.borrow();
              |VAR_DECL |assign          |apply
967             .get_handle(mod_id)
                           |apply
                            |ARG |
968             .map(|handle| v8::Local::new(scope, handle))
                    |apply
                     |ARG                                 |
                     |closure
                      |PARAM  |CLOSURE{
                              |RETURN       |apply
                                             |ARG|  |ARG ||}closure
969             .expect("Dyn import module info not found")
                       |apply
                        |ARG                             |
970         };
            |}inner
972         assert_eq!(module.get_status(), v8::ModuleStatus::Evaluated);
            |MACRO()| |macro(){                                        |}macro()
974         let module_namespace = module.get_module_namespace();
            |VAR_DECL            |assign                      |apply
975         resolver.resolve(scope, module_namespace).unwrap();
                            |apply
                             |ARG|  |ARG           |        |apply
976         scope.perform_microtask_checkpoint();
                                              |apply
977       }
          |}func
979       fn prepare_dyn_imports(
          |FUNCTION
980         &mut self,
            |PARAM  |
981         cx: &mut Context,
            |PARAM         |
982       ) -> Poll<Result<(), AnyError>> {
                                          |func{
983         let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
985         if state_rc.borrow().preparing_dyn_imports.is_empty() {
            |IF               |apply                           |apply
                                                                  |if{
986           return Poll::Ready(Ok(()));
              |RETURN           |apply
                                 |ARG |
                                   |apply
                                    |ARG
                                    |tuple(
                                     |)tuple
987         }
            |}if
989         loop {
            |LOOP|loop{
990           let r = {
              |VAR_DECL
                    |assign
                      |inner{
991             let mut state = state_rc.borrow_mut();
                |VAR_DECL     |assign              |apply
992             state.preparing_dyn_imports.poll_next_unpin(cx)
                                                           |apply
                                                            |ARG
993           };
              |}inner
994           match r {
              |MATCH  |match{
995             Poll::Pending | Poll::Ready(None) => {
                |CASE           |STRUCT()   |ARG     |inner{
997               return Poll::Ready(Ok(()));
                  |RETURN           |apply
                                     |ARG |
                                       |apply
                                        |ARG
                                        |tuple(
                                         |)tuple
998             }
                |}inner
999             Poll::Ready(Some(prepare_poll)) => {
                |CASE
                |STRUCT()   |ARG             |
                            |STRUCT()
                                 |ARG       |      |inner{
1000              let dyn_import_id = prepare_poll.0;
                  |VAR_DECL         |assign
1001              let prepare_result = prepare_poll.1;
                  |VAR_DECL          |assign
1003              match prepare_result {
                  |MATCH               |match{
1004                Ok(load) => {
                    |CASE
                    |STRUCT()
                       |ARG     |inner{
1005                  let state = state_rc.borrow_mut();
                      |VAR_DECL |assign              |apply
1006                  state.pending_dyn_imports.push(load.into_future());
                                                    |apply
                                                     |ARG             |
                                                                     |apply
1007                }
                    |}inner
1008                Err(err) => {
                    |CASE
                    |STRUCT()
                        |ARG    |inner{
1009                  self.dyn_import_error(dyn_import_id, err);
                                           |apply
                                            |ARG        |  |ARG
1010                }
                    |}inner
1011              }
                  |}match
1012            }
                |}inner
1013          }
              |}match
1014        }
            |}loop
1015      }
          |}func
1017      fn poll_dyn_imports(
          |FUNCTION
1018        &mut self,
            |PARAM  |
1019        cx: &mut Context,
            |PARAM         |
1020      ) -> Poll<Result<(), AnyError>> {
                                          |func{
1021        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
1023        if state_rc.borrow().pending_dyn_imports.is_empty() {
            |IF               |apply                         |apply
                                                                |if{
1024          return Poll::Ready(Ok(()));
              |RETURN           |apply
                                 |ARG |
                                   |apply
                                    |ARG
                                    |tuple(
                                     |)tuple
1025        }
            |}if
1027        loop {
            |LOOP|loop{
1028          let poll_result = {
              |VAR_DECL       |assign
                                |inner{
1029            let mut state = state_rc.borrow_mut();
                |VAR_DECL     |assign              |apply
1030            state.pending_dyn_imports.poll_next_unpin(cx)
                                                         |apply
                                                          |ARG
1031          };
              |}inner
1033          match poll_result {
              |MATCH            |match{
1034            Poll::Pending | Poll::Ready(None) => {
                |CASE           |STRUCT()   |ARG     |inner{
1036              return Poll::Ready(Ok(()));
                  |RETURN           |apply
                                     |ARG |
                                       |apply
                                        |ARG
                                        |tuple(
                                         |)tuple
1037            }
                |}inner
1038            Poll::Ready(Some(load_stream_poll)) => {
                |CASE
                |STRUCT()   |ARG                 |
                            |STRUCT()
                                 |ARG           |      |inner{
1039              let maybe_result = load_stream_poll.0;
                  |VAR_DECL        |assign
1040              let mut load = load_stream_poll.1;
                  |VAR_DECL    |assign
1041              let dyn_import_id = load.id;
                  |VAR_DECL         |assign
1043              if let Some(load_stream_result) = maybe_result {
                  |IF|VAR_DECL
                         |STRUCT()
                              |ARG             |  |assign        |if{
1044                match load_stream_result {
                    |MATCH                   |match{
1045                  Ok(info) => {
                      |CASE
                      |STRUCT()
                         |ARG     |inner{
1049                    match self.register_during_load(info, &mut load) {
                        |MATCH                         |apply
                                                        |ARG  |ARG    |  |match{
1050                      Ok(()) => {
                          |CASE
                          |STRUCT()
                             |ARG
                             |tuple
                             |tuple(
                              |)tuple
                                    |inner{
1052                        let state = state_rc.borrow_mut();
                            |VAR_DECL |assign              |apply
1053                        state.pending_dyn_imports.push(load.into_future());
                                                          |apply
                                                           |ARG             |
                                                                           |apply
1054                      }
                          |}inner
1055                      Err(err) => self.dyn_import_error(dyn_import_id, err),
                          |CASE
                          |STRUCT()
                              |ARG                         |apply
                                                            |ARG        |  |ARG
1056                    }
                        |}match
1057                  }
                      |}inner
1058                  Err(err) => {
                      |CASE
                      |STRUCT()
                          |ARG    |inner{
1062                    self.dyn_import_error(dyn_import_id, err)
                                             |apply
                                              |ARG        |  |ARG
1063                  }
                      |}inner
1064                }
                    |}match
1065              } else {
                  |}if
                    |ELSE|else{
1068                let module_id = load.root_module_id.unwrap();
                    |VAR_DECL     |assign                     |apply
1069                self.mod_instantiate(module_id)?;
                                        |apply
                                         |ARG    |
1070                self.dyn_mod_evaluate(dyn_import_id, module_id)?;
                                         |apply
                                          |ARG        |  |ARG    |
1071              }
                  |else}
1072            }
                |}inner
1073          }
              |}match
1074        }
            |}loop
1075      }
          |}func
1090      fn evaluate_pending_module(&mut self) {
          |FUNCTION                  |PARAM  |  |func{
1091        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
1093        let context = self.global_context();
            |VAR_DECL   |assign              |apply
1094        {
            |inner{
1095          let scope =
              |VAR_DECL |assign
1096            &mut v8::HandleScope::with_context(self.v8_isolate(), context);
                                                  |apply
                                                   |ARG            |
                                                                  |apply
                                                                      |ARG  |
1098          let mut state = state_rc.borrow_mut();
              |VAR_DECL     |assign              |apply
1100          if let Some(module_evaluation) = state.pending_mod_evaluate.as_ref() {
              |IF|VAR_DECL
                     |STRUCT()
                          |ARG            |  |assign                            |apply
                                                                                   |if{
1101            let promise = module_evaluation.promise.get(scope);
                |VAR_DECL   |assign                        |apply
                                                            |ARG|
1102            let mut sender = module_evaluation.sender.clone();
                |VAR_DECL      |assign                         |apply
1103            let promise_state = promise.state();
                |VAR_DECL         |assign        |apply
1105            match promise_state {
                |MATCH              |match{
1106              v8::PromiseState::Pending => {
                  |CASE                        |inner{
1109              }
                  |}inner
1110              v8::PromiseState::Fulfilled => {
                  |CASE                          |inner{
1111                state.pending_mod_evaluate.take();
                                                   |apply
1112                scope.perform_microtask_checkpoint();
                                                      |apply
1113                sender.try_send(Ok(())).unwrap();
                                   |apply
                                    |ARG |
                                      |apply
                                       |ARG
                                       |tuple(
                                        |)tuple   |apply
1114              }
                  |}inner
1115              v8::PromiseState::Rejected => {
                  |CASE                         |inner{
1116                let exception = promise.result(scope);
                    |VAR_DECL     |assign         |apply
                                                   |ARG|
1117                state.pending_mod_evaluate.take();
                                                   |apply
1118                drop(state);
                        |apply
                         |ARG|
1119                scope.perform_microtask_checkpoint();
                                                      |apply
1120                let err1 = exception_to_err_result::<()>(scope, exception, false)
                    |VAR_DECL|assign                     |T_ARG
                                                            |apply
                                                             |ARG|  |ARG    |  |ARG|
1121                  .map_err(|err| attach_handle_to_error(scope, err, exception))
                              |apply
                               |ARG                                              |
                               |closure
                                |PARAM
                                     |CLOSURE{            |
                                     |RETURN              ||apply
                                                            |ARG|  |ARG |ARG    ||}closure
1122                  .unwrap_err();
                                 |apply
1123                sender.try_send(Err(err1)).unwrap();
                                   |apply
                                    |ARG    |
                                       |apply
                                        |ARG         |apply
1124              }
                  |}inner
1125            }
                |}match
1126          }
              |}if
1127        };
            |}inner
1128      }
          |}func
1130      fn evaluate_dyn_imports(&mut self) {
          |FUNCTION               |PARAM  |  |func{
1131        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
1133        loop {
            |LOOP|loop{
1134          let context = self.global_context();
              |VAR_DECL   |assign              |apply
1135          let maybe_result = {
              |VAR_DECL        |assign
                                 |inner{
1136            let scope =
                |VAR_DECL |assign
1137              &mut v8::HandleScope::with_context(self.v8_isolate(), context);
                                                    |apply
                                                     |ARG            |
                                                                    |apply
                                                                        |ARG  |
1139            let mut state = state_rc.borrow_mut();
                |VAR_DECL     |assign              |apply
1140            if let Some(&dyn_import_id) =
                |IF|VAR_DECL
                       |STRUCT()
                            |ARG         |  |assign
1141              state.pending_dyn_mod_evaluate.keys().next()
                                                     |apply |apply
1142            {
                |if{
1143              let handle = state
                  |VAR_DECL  |assign
1145                .remove(&dyn_import_id)
                           |apply
                            |ARG         |
1146                .unwrap();
                           |apply
1147              drop(state);
                      |apply
                       |ARG|
1149              let module_id = handle.module_id;
                  |VAR_DECL     |assign
1150              let promise = handle.promise.get(scope);
                  |VAR_DECL   |assign             |apply
                                                   |ARG|
1151              let _module = handle.module.get(scope);
                  |VAR_DECL   |assign            |apply
                                                  |ARG|
1153              let promise_state = promise.state();
                  |VAR_DECL         |assign        |apply
1155              match promise_state {
                  |MATCH              |match{
1156                v8::PromiseState::Pending => {
                    |CASE                        |inner{
1158                    .borrow_mut()
                                   |apply
1160                    .insert(dyn_import_id, handle);
                               |apply
                                |ARG        |  |ARG |
1162                }
                    |}inner
1163                v8::PromiseState::Fulfilled => Some(Ok((dyn_import_id, module_id))),
                    |CASE                              |apply
                                                        |ARG                         |
                                                          |apply
                                                           |ARG                     |
                                                           |tuple(
                                                            |T_ELEM     |  |T_ELEM ||)tuple
1164                v8::PromiseState::Rejected => {
                    |CASE                         |inner{
1165                  let exception = promise.result(scope);
                      |VAR_DECL     |assign         |apply
                                                     |ARG|
1166                  let err1 = exception_to_err_result::<()>(scope, exception, false)
                      |VAR_DECL|assign                     |T_ARG
                                                              |apply
                                                               |ARG|  |ARG    |  |ARG|
1167                    .map_err(|err| attach_handle_to_error(scope, err, exception))
                                |apply
                                 |ARG                                              |
                                 |closure
                                  |PARAM
                                       |CLOSURE{            |
                                       |RETURN              ||apply
                                                              |ARG|  |ARG |ARG    ||}closure
1168                    .unwrap_err();
                                   |apply
1169                  Some(Err((dyn_import_id, err1)))
                          |apply
                           |ARG                     |
                              |apply
                               |ARG                |
                               |tuple(
                                |T_ELEM     |  |T_ELEM
                                                   |)tuple
1170                }
                    |}inner
1171              }
                  |}match
1172            } else {
                |}if
                  |ELSE|else{
1174            }
                |else}
1175          };
              |}inner
1177          if let Some(result) = maybe_result {
              |IF|VAR_DECL
                     |STRUCT()
                          |ARG |  |assign        |if{
1178            match result {
                |MATCH       |match{
1179              Ok((dyn_import_id, module_id)) => {
                  |CASE
                  |STRUCT()
                     |ARG                     |
                     |tuple
                     |tuple(
                      |T_ELEM     |  |T_ELEM ||)tuple
                                                    |inner{
1180                self.dyn_import_done(dyn_import_id, module_id);
                                        |apply
                                         |ARG        |  |ARG    |
1181              }
                  |}inner
1182              Err((dyn_import_id, err1)) => {
                  |CASE
                  |STRUCT()
                      |ARG                |
                      |tuple
                      |tuple(
                       |T_ELEM     |  |T_ELEM
                                          |)tuple
                                                |inner{
1183                self.dyn_import_error(dyn_import_id, err1);
                                         |apply
                                          |ARG        |  |ARG
1184              }
                  |}inner
1185            }
                |}match
1186          } else {
              |}if
                |ELSE|else{
1187            break;
                |BREAK
1188          }
              |else}
1189        }
            |}loop
1190      }
          |}func
1192      fn register_during_load(
          |FUNCTION
1193        &mut self,
            |PARAM  |
1194        info: ModuleSource,
            |PARAM           |
1195        load: &mut RecursiveModuleLoad,
            |PARAM                       |
1196      ) -> Result<(), AnyError> {
                                    |func{
1197        let ModuleSource {
            |VAR_DECL
                |STRUCT    | |struct{
1198          code,
              |FIELD
1199          module_url_specified,
              |FIELD             |
1200          module_url_found,
              |FIELD         |
1201        } = info;
            |}struct
              |assign
1203        let is_main =
            |VAR_DECL   |assign
1204          load.state == LoadState::LoadingRoot && !load.is_dynamic_import();
                                                                             |apply
1205        let referrer_specifier =
            |VAR_DECL              |assign
1206          ModuleSpecifier::resolve_url(&module_url_found).unwrap();
                                          |apply
                                           |ARG            |        |apply
1208        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
1220        if module_url_specified != module_url_found {
            |IF                                         |if{
1221          let mut state = state_rc.borrow_mut();
              |VAR_DECL     |assign              |apply
1224            .alias(&module_url_specified, &module_url_found);
                      |apply
                       |ARG                |  |ARG            |
1225        }
            |}if
1227        let maybe_mod_id = {
            |VAR_DECL        |assign
                               |inner{
1228          let state = state_rc.borrow();
              |VAR_DECL |assign          |apply
1229          state.modules.get_id(&module_url_found)
                                  |apply
                                   |ARG            |
1230        };
            |}inner
1232        let module_id = match maybe_mod_id {
            |VAR_DECL     |assign
                            |MATCH             |match{
1233          Some(id) => {
              |CASE
              |STRUCT()
                   |ARG   |inner{
1235            debug!(
                |MACRO()
                      |macro(){
1238            );
                |}macro()
1240          }
              |}inner
1242          None => self.mod_new(is_main, &module_url_found, &code)?,
              |CASE               |apply
                                   |ARG  |  |ARG            |  |ARG|
1243        };
            |}match
1246        let imports = {
            |VAR_DECL   |assign
                          |inner{
1247          let state_rc = Self::state(self.v8_isolate());
              |VAR_DECL    |assign      |apply
                                         |ARG            |
                                                        |apply
1248          let state = state_rc.borrow();
              |VAR_DECL |assign          |apply
1249          state.modules.get_children(module_id).unwrap().clone()
                                        |apply
                                         |ARG    |        |apply  |apply
1250        };
            |}inner
1252        for module_specifier in imports {
            |FOR                            |for{
1253          let is_registered = {
              |VAR_DECL         |assign
                                  |inner{
1254            let state_rc = Self::state(self.v8_isolate());
                |VAR_DECL    |assign      |apply
                                           |ARG            |
                                                          |apply
1255            let state = state_rc.borrow();
                |VAR_DECL |assign          |apply
1256            state.modules.is_registered(&module_specifier)
                                           |apply
                                            |ARG            |
1257          };
              |}inner
1258          if !is_registered {
              |IF               |if{
1260              .add_import(module_specifier.to_owned(), referrer_specifier.clone());
                             |apply
                              |ARG                      |
                                                       |apply
                                                           |ARG                     |
                                                                                   |apply
1261          }
              |}if
1262        }
            |}for
1265        if load.state == LoadState::LoadingRoot {
            |IF                                     |if{
1266          load.root_module_id = Some(module_id);
                                  |assign
                                        |apply
                                         |ARG    |
1267          load.state = LoadState::LoadingImports;
                         |assign
1268        }
            |}if
1270        if load.pending.is_empty() {
            |IF                     |apply
                                       |if{
1271          load.state = LoadState::Done;
                         |assign
1272        }
            |}if
1274        Ok(())
              |apply
               |ARG
               |tuple(
                |)tuple
1275      }
          |}func
1281      pub async fn load_module(
                    |FUNCTION
1282        &mut self,
            |PARAM  |
1283        specifier: &ModuleSpecifier,
            |PARAM                    |
1284        code: Option<String>,
            |PARAM             |
1285      ) -> Result<ModuleId, AnyError> {
                                          |func{
1286        self.shared_init();
                            |apply
1287        let loader = {
            |VAR_DECL  |assign
                         |inner{
1288          let state_rc = Self::state(self.v8_isolate());
              |VAR_DECL    |assign      |apply
                                         |ARG            |
                                                        |apply
1289          let state = state_rc.borrow();
              |VAR_DECL |assign          |apply
1290          state.loader.clone()
                                |apply
1291        };
            |}inner
1293        let load = RecursiveModuleLoad::main(
            |VAR_DECL|assign                    |apply
1294          self.op_state(),
              |ARG          |
                           |apply
1295          &specifier.to_string(),
              |ARG                 |
                                  |apply
1296          code,
              |ARG
1297          loader,
              |ARG |
1299        let (_load_id, prepare_result) = load.prepare().await;
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM|  |T_ELEM      ||)tuple
                                           |assign       |apply
1301        let mut load = prepare_result?;
            |VAR_DECL    |assign
1303        while let Some(info_result) = load.next().await {
            |LOOP |VAR_DECL
                      |STRUCT()
                           |ARG      |  |assign    |apply   |loop{
1304          let info = info_result?;
              |VAR_DECL|assign
1305          self.register_during_load(info, &mut load)?;
                                       |apply
                                        |ARG  |ARG    |
1306        }
            |}loop
1308        let root_id = load.root_module_id.expect("Root module id empty");
            |VAR_DECL   |assign                     |apply
                                                     |ARG                 |
1309        self.mod_instantiate(root_id).map(|_| root_id)
                                |apply
                                 |ARG  |     |apply
                                              |ARG      |
                                              |closure
                                               |param
                                                  |CLOSURE{
                                                  |RETURN
                                                  |}CLOSURE
1310      }
          |}func
1312      fn poll_pending_ops(
          |FUNCTION
1313        &mut self,
            |PARAM  |
1314        cx: &mut Context,
            |PARAM         |
1315      ) -> Option<(OpId, Box<[u8]>)> {
                                         |func{
1316        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
1317        let mut overflow_response: Option<(OpId, Box<[u8]>)> = None;
            |VAR_DECL                                            |assign
1319        loop {
            |LOOP|loop{
1320          let mut state = state_rc.borrow_mut();
              |VAR_DECL     |assign              |apply
1322          state.have_unpolled_ops.set(false);
                                         |apply
                                          |ARG|
1324          let pending_r = state.pending_ops.poll_next_unpin(cx);
              |VAR_DECL     |assign                            |apply
                                                                |ARG
1325          match pending_r {
              |MATCH          |match{
1326            Poll::Ready(None) => break,
                |CASE
                |STRUCT()   |ARG     |BREAK
1327            Poll::Pending => break,
                |CASE            |BREAK
1328            Poll::Ready(Some((op_id, buf))) => {
                |CASE
                |STRUCT()   |ARG             |
                            |STRUCT()
                                 |ARG       |
                                 |tuple
                                 |tuple(
                                  |T_ELEM|T_ELEM
                                            |)tuple|inner{
1329              let successful_push = state.shared.push(op_id, &buf);
                  |VAR_DECL           |assign            |apply
                                                          |ARG|  |ARG
1330              if !successful_push {
                  |IF                 |if{
1334                overflow_response = Some((op_id, buf));
                                      |assign
                                            |apply
                                             |ARG       |
                                             |tuple(
                                              |T_ELEM|T_ELEM
                                                        |)tuple
1335                break;
                    |BREAK
1336              }
                  |}if
1337            }
                |}inner
1338          };
              |}match
1339        }
            |}loop
1341        loop {
            |LOOP|loop{
1342          let mut state = state_rc.borrow_mut();
              |VAR_DECL     |assign              |apply
1343          let unref_r = state.pending_unref_ops.poll_next_unpin(cx);
              |VAR_DECL   |assign                                  |apply
                                                                    |ARG
1344          #[allow(clippy::match_wild_err_arm)]
              |OUTER_ATTR                        |
1345          match unref_r {
              |MATCH        |match{
1346            Poll::Ready(None) => break,
                |CASE
                |STRUCT()   |ARG     |BREAK
1347            Poll::Pending => break,
                |CASE            |BREAK
1348            Poll::Ready(Some((op_id, buf))) => {
                |CASE
                |STRUCT()   |ARG             |
                            |STRUCT()
                                 |ARG       |
                                 |tuple
                                 |tuple(
                                  |T_ELEM|T_ELEM
                                            |)tuple|inner{
1349              let successful_push = state.shared.push(op_id, &buf);
                  |VAR_DECL           |assign            |apply
                                                          |ARG|  |ARG
1350              if !successful_push {
                  |IF                 |if{
1354                overflow_response = Some((op_id, buf));
                                      |assign
                                            |apply
                                             |ARG       |
                                             |tuple(
                                              |T_ELEM|T_ELEM
                                                        |)tuple
1355                break;
                    |BREAK
1356              }
                  |}if
1357            }
                |}inner
1358          };
              |}match
1359        }
            |}loop
1362      }
          |}func
1364      fn check_promise_exceptions(&mut self) -> Result<(), AnyError> {
          |FUNCTION                   |PARAM  |                          |func{
1365        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
1366        let mut state = state_rc.borrow_mut();
            |VAR_DECL     |assign              |apply
1368        if state.pending_promise_exceptions.is_empty() {
            |IF                                         |apply
                                                           |if{
1369          return Ok(());
              |RETURN  |apply
                        |ARG
                        |tuple(
                         |)tuple
1370        }
            |}if
1372        let key = {
            |VAR_DECL
                    |assign
                      |inner{
1375            .keys()
                     |apply
1376            .next()
                     |apply
1377            .unwrap()
                       |apply
1378            .clone()
                      |apply
1379        };
            |}inner
1380        let handle = state.pending_promise_exceptions.remove(&key).unwrap();
            |VAR_DECL  |assign                                  |apply
                                                                 |ARG        |apply
1381        drop(state);
                |apply
                 |ARG|
1383        let context = self.global_context();
            |VAR_DECL   |assign              |apply
1384        let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |
1386        let exception = v8::Local::new(scope, handle);
            |VAR_DECL     |assign         |apply
                                           |ARG|  |ARG |
1387        exception_to_err_result(scope, exception, true)
                                   |apply
                                    |ARG|  |ARG    |  |ARG
1388      }
          |}func
1391      fn async_op_response(
          |FUNCTION
1392        &mut self,
            |PARAM  |
1393        maybe_overflown_response: Option<(OpId, Box<[u8]>)>,
            |PARAM                                            |
1394      ) -> Result<(), AnyError> {
                                    |func{
1395        let state_rc = Self::state(self.v8_isolate());
            |VAR_DECL    |assign      |apply
                                       |ARG            |
                                                      |apply
1397        let shared_queue_size = state_rc.borrow().shared.size();
            |VAR_DECL             |assign          |apply        |apply
1399        if shared_queue_size == 0 && maybe_overflown_response.is_none() {
            |IF                                                          |apply
                                                                            |if{
1400          return Ok(());
              |RETURN  |apply
                        |ARG
                        |tuple(
                         |)tuple
1401        }
            |}if
1406        let js_recv_cb_handle = state_rc
            |VAR_DECL             |assign
1407          .borrow()
                     |apply
1409          .clone()
                    |apply
1410          .expect("Deno.core.recv has not been called.");
                     |apply
                      |ARG                                |
1412        let context = self.global_context();
            |VAR_DECL   |assign              |apply
1413        let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |
1414        let context = scope.get_current_context();
            |VAR_DECL   |assign                    |apply
1415        let global: v8::Local<v8::Value> = context.global(scope).into();
            |VAR_DECL                        |assign         |apply
                                                              |ARG|      |apply
1416        let js_recv_cb = js_recv_cb_handle.get(scope);
            |VAR_DECL      |assign                |apply
                                                   |ARG|
1418        let tc_scope = &mut v8::TryCatch::new(scope);
            |VAR_DECL    |assign                 |apply
                                                  |ARG|
1420        if shared_queue_size > 0 {
            |IF                      |if{
1421          js_recv_cb.call(tc_scope, global, &[]);
                             |apply
                              |ARG   |  |ARG |  |ARG
                                                 |array{
                                                  |}array
1423          let shared_queue_size = state_rc.borrow().shared.size();
              |VAR_DECL             |assign          |apply        |apply
1424          assert_eq!(shared_queue_size, 0);
              |MACRO()| |macro(){            |}macro()
1425        }
            |}if
1427        if let Some(overflown_response) = maybe_overflown_response {
            |IF|VAR_DECL
                   |STRUCT()
                        |ARG             |  |assign                    |if{
1428          let (op_id, buf) = overflown_response;
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM|T_ELEM
                             |)tuple
                               |assign
1429          let op_id: v8::Local<v8::Value> =
              |VAR_DECL                       |assign
1430            v8::Integer::new(tc_scope, op_id as i32).into();
                                |apply
                                 |ARG   |  |ARG       |      |apply
1431          let ui8: v8::Local<v8::Value> =
              |VAR_DECL                     |assign
1432            bindings::boxed_slice_to_uint8array(tc_scope, buf).into();
                                                   |apply
                                                    |ARG   |  |ARG     |apply
1433          js_recv_cb.call(tc_scope, global, &[op_id, ui8]);
                             |apply
                              |ARG   |  |ARG |  |ARG        |
                                                 |array{
                                                  |ARRAY_ELEM
                                                         |ARRAY_ELEM
                                                            |}array
1434        }
            |}if
1436        match tc_scope.exception() {
            |MATCH                  |apply
                                       |match{
1437          None => Ok(()),
              |CASE     |apply
                         |ARG
                         |tuple(
                          |)tuple
1438          Some(exception) => exception_to_err_result(tc_scope, exception, false),
              |CASE
              |STRUCT()
                   |ARG    |                            |apply
                                                         |ARG   |  |ARG    |  |ARG|
1439        }
            |}match
1440      }
          |}func
1442      fn drain_macrotasks(&mut self) -> Result<(), AnyError> {
          |FUNCTION           |PARAM  |                          |func{
1443        let js_macrotask_cb_handle =
            |VAR_DECL                  |assign
1444          match &Self::state(self.v8_isolate()).borrow().js_macrotask_cb {
              |MATCH            |apply
                                 |ARG            |
                                                |apply    |apply             |match{
1445            Some(handle) => handle.clone(),
                |CASE
                |STRUCT()
                     |ARG |                 |apply
1446            None => return Ok(()),
                |CASE   |RETURN  |apply
                                  |ARG
                                  |tuple(
                                   |)tuple
1447          };
              |}match
1449        let context = self.global_context();
            |VAR_DECL   |assign              |apply
1450        let scope = &mut v8::HandleScope::with_context(self.v8_isolate(), context);
            |VAR_DECL |assign                             |apply
                                                           |ARG            |
                                                                          |apply
                                                                              |ARG  |
1451        let context = scope.get_current_context();
            |VAR_DECL   |assign                    |apply
1452        let global: v8::Local<v8::Value> = context.global(scope).into();
            |VAR_DECL                        |assign         |apply
                                                              |ARG|      |apply
1453        let js_macrotask_cb = js_macrotask_cb_handle.get(scope);
            |VAR_DECL           |assign                     |apply
                                                             |ARG|
1458        let tc_scope = &mut v8::TryCatch::new(scope);
            |VAR_DECL    |assign                 |apply
                                                  |ARG|
1460        loop {
            |LOOP|loop{
1461          let is_done = js_macrotask_cb.call(tc_scope, global, &[]);
              |VAR_DECL   |assign               |apply
                                                 |ARG   |  |ARG |  |ARG
                                                                    |array{
                                                                     |}array
1463          if let Some(exception) = tc_scope.exception() {
              |IF|VAR_DECL
                     |STRUCT()
                          |ARG    |  |assign             |apply
                                                            |if{
1464            return exception_to_err_result(tc_scope, exception, false);
                |RETURN                       |apply
                                               |ARG   |  |ARG    |  |ARG|
1465          }
              |}if
1467          let is_done = is_done.unwrap();
              |VAR_DECL   |assign         |apply
1468          if is_done.is_true() {
              |IF               |apply
                                   |if{
1469            break;
                |BREAK
1470          }
              |}if
1471        }
            |}loop
1473        Ok(())
              |apply
               |ARG
               |tuple(
                |)tuple
1474      }
          |}func
1475    }
        |}impl
1477    #[cfg(test)]
        |OUTER_ATTR|
1478    pub mod tests {
            |MODULE   |module{
1479      use super::*;
          |USE       |use_item
1480      use crate::modules::ModuleSourceFuture;
          |USE|USE_ITEM                        |
1481      use crate::BufVec;
          |USE|USE_ITEM   |
1482      use futures::future::lazy;
          |USE|USE_ITEM           |
1483      use futures::FutureExt;
          |USE|USE_ITEM        |
1484      use std::io;
          |USE|USE_ITEM
1485      use std::ops::FnOnce;
          |USE|USE_ITEM      |
1486      use std::rc::Rc;
          |USE|USE_ITEM |
1487      use std::sync::atomic::{AtomicUsize, Ordering};
          |USE                    |USE_ITEM |  |USE_ITEM
1488      use std::sync::Arc;
          |USE|USE_ITEM    |
1490      pub fn run_in_task<F>(f: F)
              |FUNCTION      |<t>
                                |PARAM
1493      {
          |func{
1494        futures::executor::block_on(lazy(move |cx| f(cx)));
                                       |apply
                                        |ARG                |
                                            |apply
                                             |ARG          |
                                             |CLOSURE
                                                   |PARAM
                                                       |closure{
                                                       |return
                                                        |apply
                                                         |ARG
                                                           |}closure
1495      }
          |}func
1497      fn poll_until_ready(
          |FUNCTION
1498        runtime: &mut JsRuntime,
            |PARAM                |
1499        max_poll_count: usize,
            |PARAM              |
1500      ) -> Result<(), AnyError> {
                                    |func{
1501        let mut cx = Context::from_waker(futures::task::noop_waker_ref());
            |VAR_DECL  |assign              |apply
                                             |ARG                          |
                                                                          |apply
1502        for _ in 0..max_poll_count {
            |FOR                       |for{
1503          match runtime.poll_event_loop(&mut cx) {
              |MATCH                       |apply
                                            |ARG  |  |match{
1504            Poll::Pending => continue,
                |CASE
1505            Poll::Ready(val) => return val,
                |CASE
                |STRUCT()   |ARG    |RETURN
1506          }
              |}match
1507        }
            |}for
1508        panic!(
            |MACRO()
                  |macro(){
1511        )
            |}macro()
1512      }
          |}func
1514      enum Mode {
          |ENUM     |enum{
1515        Async,
            |ENUM_ITEM
1516        AsyncUnref,
            |ENUM_ITEM
1517        AsyncZeroCopy(u8),
            |ENUM_ITEM  ||tuple(
                          |T_ELEM
                            |)tuple
1518        OverflowReqSync,
            |ENUM_ITEM    |
1519        OverflowResSync,
            |ENUM_ITEM    |
1520        OverflowReqAsync,
            |ENUM_ITEM     |
1521        OverflowResAsync,
            |ENUM_ITEM     |
1522      }
          |}enum
1524      struct TestState {
          |STRUCT          |struct{
1525        mode: Mode,
            |FIELD
1526        dispatch_count: Arc<AtomicUsize>,
            |FIELD       |
1527      }
          |}struct
1529      fn dispatch(op_state: Rc<RefCell<OpState>>, bufs: BufVec) -> Op {
          |FUNCTION   |PARAM                       |  |PARAM     |        |func{
1530        let op_state_ = op_state.borrow();
            |VAR_DECL     |assign          |apply
1531        let test_state = op_state_.borrow::<TestState>();
            |VAR_DECL      |assign              |T_ARG  | |apply
1532        test_state.dispatch_count.fetch_add(1, Ordering::Relaxed);
                                               |apply
                                                |arg
                                                   |ARG            |
1533        match test_state.mode {
            |MATCH                |match{
1534          Mode::Async => {
              |CASE          |inner{
1535            assert_eq!(bufs.len(), 1);
                |MACRO()| |macro(){     |}macro()
1536            assert_eq!(bufs[0].len(), 1);
                |MACRO()| |macro(){        |}macro()
1537            assert_eq!(bufs[0][0], 42);
                |MACRO()| |macro(){      |}macro()
1538            let buf = vec![43u8].into_boxed_slice();
                |VAR_DECL
                        |assign
                          |MACRO()
                              |macro(){
                                   |}macro()         |apply
1539            Op::Async(futures::future::ready(buf).boxed())
                         |apply
                          |ARG                              |
                                                |apply
                                                 |ARG      |apply
1540          }
              |}inner
1541          Mode::AsyncUnref => {
              |CASE               |inner{
1542            assert_eq!(bufs.len(), 1);
                |MACRO()| |macro(){     |}macro()
1543            assert_eq!(bufs[0].len(), 1);
                |MACRO()| |macro(){        |}macro()
1544            assert_eq!(bufs[0][0], 42);
                |MACRO()| |macro(){      |}macro()
1545            let fut = async {
                |VAR_DECL
                        |assign |inner{
1547              futures::future::pending::<()>().await;
                                             |T_ARG
                                                |apply
1548              vec![43u8].into_boxed_slice()
                  |MACRO()
                      |macro(){
                           |}macro()         |apply
1549            };
                |}inner
1550            Op::AsyncUnref(fut.boxed())
                              |apply
                               |ARG      |
                                        |apply
1551          }
              |}inner
1552          Mode::AsyncZeroCopy(count) => {
              |CASE
              |STRUCT()           |ARG|     |inner{
1553            assert_eq!(bufs.len(), count as usize);
                |MACRO()| |macro(){                  |}macro()
1554            bufs.iter().enumerate().for_each(|(idx, buf)| {
                         |apply      |apply     |apply
                                                 |ARG
                                                 |closure
                                                  |param
                                                  |tuple
                                                  |tuple(
                                                   |T_ELEM
                                                        |T_ELEM
                                                           |)tuple
                                                              |closure{
                                                              |return
                                                              |inner{
1555              assert_eq!(buf.len(), 1);
                  |MACRO()| |macro(){    |}macro()
1556              assert_eq!(idx, buf[0] as usize);
                  |MACRO()| |macro(){            |}macro()
1557            });
                |}inner
                |}closure
1559            let buf = vec![43u8].into_boxed_slice();
                |VAR_DECL
                        |assign
                          |MACRO()
                              |macro(){
                                   |}macro()         |apply
1560            Op::Async(futures::future::ready(buf).boxed())
                         |apply
                          |ARG                              |
                                                |apply
                                                 |ARG      |apply
1561          }
              |}inner
1562          Mode::OverflowReqSync => {
              |CASE                    |inner{
1563            assert_eq!(bufs.len(), 1);
                |MACRO()| |macro(){     |}macro()
1564            assert_eq!(bufs[0].len(), 100 * 1024 * 1024);
                |MACRO()| |macro(){                        |}macro()
1565            let buf = vec![43u8].into_boxed_slice();
                |VAR_DECL
                        |assign
                          |MACRO()
                              |macro(){
                                   |}macro()         |apply
1566            Op::Sync(buf)
                        |apply
                         |ARG
1567          }
              |}inner
1568          Mode::OverflowResSync => {
              |CASE                    |inner{
1569            assert_eq!(bufs.len(), 1);
                |MACRO()| |macro(){     |}macro()
1570            assert_eq!(bufs[0].len(), 1);
                |MACRO()| |macro(){        |}macro()
1571            assert_eq!(bufs[0][0], 42);
                |MACRO()| |macro(){      |}macro()
1572            let mut vec = vec![0u8; 100 * 1024 * 1024];
                |VAR_DECL   |assign
                              |MACRO()
                                  |macro(){              |}macro()
1573            vec[0] = 99;
                       |assign
1574            let buf = vec.into_boxed_slice();
                |VAR_DECL
                        |assign               |apply
1575            Op::Sync(buf)
                        |apply
                         |ARG
1576          }
              |}inner
1577          Mode::OverflowReqAsync => {
              |CASE                     |inner{
1578            assert_eq!(bufs.len(), 1);
                |MACRO()| |macro(){     |}macro()
1579            assert_eq!(bufs[0].len(), 100 * 1024 * 1024);
                |MACRO()| |macro(){                        |}macro()
1580            let buf = vec![43u8].into_boxed_slice();
                |VAR_DECL
                        |assign
                          |MACRO()
                              |macro(){
                                   |}macro()         |apply
1581            Op::Async(futures::future::ready(buf).boxed())
                         |apply
                          |ARG                              |
                                                |apply
                                                 |ARG      |apply
1582          }
              |}inner
1583          Mode::OverflowResAsync => {
              |CASE                     |inner{
1584            assert_eq!(bufs.len(), 1);
                |MACRO()| |macro(){     |}macro()
1585            assert_eq!(bufs[0].len(), 1);
                |MACRO()| |macro(){        |}macro()
1586            assert_eq!(bufs[0][0], 42);
                |MACRO()| |macro(){      |}macro()
1587            let mut vec = vec![0u8; 100 * 1024 * 1024];
                |VAR_DECL   |assign
                              |MACRO()
                                  |macro(){              |}macro()
1588            vec[0] = 4;
                       |assign
1589            let buf = vec.into_boxed_slice();
                |VAR_DECL
                        |assign               |apply
1590            Op::Async(futures::future::ready(buf).boxed())
                         |apply
                          |ARG                              |
                                                |apply
                                                 |ARG      |apply
1591          }
              |}inner
1592        }
            |}match
1593      }
          |}func
1595      fn setup(mode: Mode) -> (JsRuntime, Arc<AtomicUsize>) {
          |FUNCTION|PARAM   |                                   |func{
1596        let dispatch_count = Arc::new(AtomicUsize::new(0));
            |VAR_DECL          |assign   |apply
                                          |ARG              |
                                                          |apply
                                                           |arg
1597        let mut runtime = JsRuntime::new(Default::default());
            |VAR_DECL       |assign         |apply
                                             |ARG             |
                                                             |apply
1598        let op_state = runtime.op_state();
            |VAR_DECL    |assign           |apply
1599        op_state.borrow_mut().put(TestState {
                               |apply|apply
                                      |ARG
                                      |STRUCT()
1600          mode,
              |ARG
1601          dispatch_count: dispatch_count.clone(),
              |ARG                                 |
                                                  |apply
1604        runtime.register_op("test", dispatch);
                               |apply
                                |ARG |  |ARG   |
1607          .execute(
                      |apply
1608            "setup.js",
                |ARG     |
1609            r#"
                |ARG
1617          .unwrap();
                     |apply
1618        assert_eq!(dispatch_count.load(Ordering::Relaxed), 0);
            |MACRO()| |macro(){                                 |}macro()
1619        (runtime, dispatch_count)
            |tuple(
             |T_ELEM  |T_ELEM      ||)tuple
1620      }
          |}func
1622      #[test]
          |OUTER_ATTR
1623      fn test_dispatch() {
          |FUNCTION          |func{
1624        let (mut runtime, dispatch_count) = setup(Mode::Async);
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM      ||)tuple
                                              |assign|apply
                                                      |ARG      |
1626          .execute(
                      |apply
1627            "filename.js",
                |ARG        |
1628            r#"
                |ARG
1637          .unwrap();
                     |apply
1638        assert_eq!(dispatch_count.load(Ordering::Relaxed), 2);
            |MACRO()| |macro(){                                 |}macro()
1639      }
          |}func
1641      #[test]
          |OUTER_ATTR
1642      fn test_dispatch_no_zero_copy_buf() {
          |FUNCTION                           |func{
1643        let (mut runtime, dispatch_count) = setup(Mode::AsyncZeroCopy(0));
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM      ||)tuple
                                              |assign|apply
                                                      |ARG                 |
                                                                         |apply
                                                                          |arg
1645          .execute(
                      |apply
1646            "filename.js",
                |ARG        |
1647            r#"
                |ARG
1651          .unwrap();
                     |apply
1652        assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
            |MACRO()| |macro(){                                 |}macro()
1653      }
          |}func
1655      #[test]
          |OUTER_ATTR
1656      fn test_dispatch_stack_zero_copy_bufs() {
          |FUNCTION                               |func{
1657        let (mut runtime, dispatch_count) = setup(Mode::AsyncZeroCopy(2));
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM      ||)tuple
                                              |assign|apply
                                                      |ARG                 |
                                                                         |apply
                                                                          |arg
1659          .execute(
                      |apply
1660            "filename.js",
                |ARG        |
1661            r#"
                |ARG
1667          .unwrap();
                     |apply
1668        assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
            |MACRO()| |macro(){                                 |}macro()
1669      }
          |}func
1671      #[test]
          |OUTER_ATTR
1672      fn test_dispatch_heap_zero_copy_bufs() {
          |FUNCTION                              |func{
1673        let (mut runtime, dispatch_count) = setup(Mode::AsyncZeroCopy(5));
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM      ||)tuple
                                              |assign|apply
                                                      |ARG                 |
                                                                         |apply
                                                                          |arg
1674        runtime.execute(
                           |apply
1675          "filename.js",
              |ARG        |
1676          r#"
              |ARG
1684        ).unwrap();
                    |apply
1685        assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
            |MACRO()| |macro(){                                 |}macro()
1686      }
          |}func
1688      #[test]
          |OUTER_ATTR
1689      fn test_poll_async_delayed_ops() {
          |FUNCTION                        |func{
1690        run_in_task(|cx| {
                       |apply
                        |ARG
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{
1691          let (mut runtime, dispatch_count) = setup(Mode::Async);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM      ||)tuple
                                                |assign|apply
                                                        |ARG      |
1694            .execute(
                        |apply
1695              "setup2.js",
                  |ARG      |
1696              r#"
                  |ARG
1703            .unwrap();
                       |apply
1704          assert_eq!(dispatch_count.load(Ordering::Relaxed), 0);
              |MACRO()| |macro(){                                 |}macro()
1706            .execute(
                        |apply
1707              "check1.js",
                  |ARG      |
1708              r#"
                  |ARG
1715            .unwrap();
                       |apply
1716          assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                 |}macro()
1717          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()
1718          assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                 |}macro()
1720            .execute(
                        |apply
1721              "check2.js",
                  |ARG      |
1722              r#"
                  |ARG
1728            .unwrap();
                       |apply
1729          assert_eq!(dispatch_count.load(Ordering::Relaxed), 2);
              |MACRO()| |macro(){                                 |}macro()
1730          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()
1731          runtime.execute("check3.js", "assert(nrecv == 2)").unwrap();
                             |apply
                              |ARG      |  |ARG               |        |apply
1732          assert_eq!(dispatch_count.load(Ordering::Relaxed), 2);
              |MACRO()| |macro(){                                 |}macro()
1734          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()
1735        });
            |}inner
            |}closure
1736      }
          |}func
1738      #[test]
          |OUTER_ATTR
1739      fn test_poll_async_optional_ops() {
          |FUNCTION                         |func{
1740        run_in_task(|cx| {
                       |apply
                        |ARG
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{
1741          let (mut runtime, dispatch_count) = setup(Mode::AsyncUnref);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM      ||)tuple
                                                |assign|apply
                                                        |ARG           |
1743            .execute(
                        |apply
1744              "check1.js",
                  |ARG      |
1745              r#"
                  |ARG
1754            .unwrap();
                       |apply
1755          assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                 |}macro()
1758          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()
1759        })
            |}inner
            |}closure
1760      }
          |}func
1762      #[test]
          |OUTER_ATTR
1763      fn terminate_execution() {
          |FUNCTION                |func{
1764        let (mut isolate, _dispatch_count) = setup(Mode::Async);
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM       ||)tuple
                                               |assign|apply
                                                       |ARG      |
1767        let v8_isolate_handle = isolate.v8_isolate().thread_safe_handle();
            |VAR_DECL             |assign             |apply               |apply
1769        let terminator_thread = std::thread::spawn(move || {
            |VAR_DECL             |assign             |apply
                                                       |ARG
                                                       |CLOSURE|closure{
                                                               |return
                                                               |inner{
1771          std::thread::sleep(std::time::Duration::from_millis(100));
                                |apply
                                 |ARG                                |
                                                                 |apply
                                                                  |ARG
1774          let ok = v8_isolate_handle.terminate_execution();
              |VAR_DECL
                     |assign                                |apply
1775          assert!(ok);
              |MACRO()
                     |macro(){
                        |}macro()
1776        });
            |}inner
            |}closure
1779        match isolate.execute("infinite_loop.js", "for(;;) {}") {
            |MATCH               |apply
                                  |ARG             |  |ARG       |  |match{
1780          Ok(_) => panic!("execution should be terminated"),
              |CASE
              |STRUCT()
                 |arg  |MACRO()
                             |macro(){                        |}macro()
1781          Err(e) => {
              |CASE
              |STRUCT()
                  |arg  |inner{
1782            assert_eq!(e.to_string(), "Uncaught Error: execution terminated")
                |MACRO()| |macro(){                                             |}macro()
1783          }
              |}inner
1784        };
            |}match
1790        let ok = isolate
            |VAR_DECL
                   |assign
1791          .v8_isolate()
                         |apply
1792          .thread_safe_handle()
                                 |apply
1793          .cancel_terminate_execution();
                                         |apply
1794        assert!(ok);
            |MACRO()
                   |macro(){
                      |}macro()
1798          .execute("simple.js", "1 + 1")
                      |apply
                       |ARG      |  |ARG  |
1799          .expect("execution should be possible again");
                     |apply
                      |ARG                               |
1801        terminator_thread.join().unwrap();
                                  |apply   |apply
1802      }
          |}func
1804      #[test]
          |OUTER_ATTR
1805      fn dangling_shared_isolate() {
          |FUNCTION                    |func{
1806        let v8_isolate_handle = {
            |VAR_DECL             |assign
                                    |inner{
1808          let (mut runtime, _dispatch_count) = setup(Mode::Async);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM       ||)tuple
                                                 |assign|apply
                                                         |ARG      |
1811          runtime.v8_isolate().thread_safe_handle()
                                |apply               |apply
1812        };
            |}inner
1815        v8_isolate_handle.terminate_execution();
                                                 |apply
1816      }
          |}func
1818      #[test]
          |OUTER_ATTR
1819      fn overflow_req_sync() {
          |FUNCTION              |func{
1820        let (mut runtime, dispatch_count) = setup(Mode::OverflowReqSync);
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM      ||)tuple
                                              |assign|apply
                                                      |ARG                |
1822          .execute(
                      |apply
1823            "overflow_req_sync.js",
                |ARG                 |
1824            r#"
                |ARG
1836          .unwrap();
                     |apply
1837        assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
            |MACRO()| |macro(){                                 |}macro()
1838      }
          |}func
1840      #[test]
          |OUTER_ATTR
1841      fn overflow_res_sync() {
          |FUNCTION              |func{
1844        let (mut runtime, dispatch_count) = setup(Mode::OverflowResSync);
            |VAR_DECL
                |tuple
                |tuple(
                 |T_ELEM      |T_ELEM      ||)tuple
                                              |assign|apply
                                                      |ARG                |
1846          .execute(
                      |apply
1847            "overflow_res_sync.js",
                |ARG                 |
1848            r#"
                |ARG
1860          .unwrap();
                     |apply
1861        assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
            |MACRO()| |macro(){                                 |}macro()
1862      }
          |}func
1864      #[test]
          |OUTER_ATTR
1865      fn overflow_req_async() {
          |FUNCTION               |func{
1866        run_in_task(|cx| {
                       |apply
                        |ARG
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{
1867          let (mut runtime, dispatch_count) = setup(Mode::OverflowReqAsync);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM      ||)tuple
                                                |assign|apply
                                                        |ARG                 |
1869            .execute(
                        |apply
1870              "overflow_req_async.js",
                  |ARG                  |
1871              r#"
                  |ARG
1886            .unwrap();
                       |apply
1887          assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                 |}macro()
1888          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()
1890            .execute("check.js", "assert(asyncRecv == 1);")
                        |apply
                         |ARG     |  |ARG                    |
1891            .unwrap();
                       |apply
1892        });
            |}inner
            |}closure
1893      }
          |}func
1895      #[test]
          |OUTER_ATTR
1896      fn overflow_res_async() {
          |FUNCTION               |func{
1897        run_in_task(|_cx| {
                       |apply
                        |ARG
                        |closure
                         |PARAM
                              |closure{
                              |return
                              |inner{
1900          let (mut runtime, dispatch_count) = setup(Mode::OverflowResAsync);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM      ||)tuple
                                                |assign|apply
                                                        |ARG                 |
1902            .execute(
                        |apply
1903              "overflow_res_async.js",
                  |ARG                  |
1904              r#"
                  |ARG
1918            .unwrap();
                       |apply
1919          assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                 |}macro()
1920          poll_until_ready(&mut runtime, 3).unwrap();
                              |apply
                               |ARG       |  |arg     |apply
1922            .execute("check.js", "assert(asyncRecv == 1);")
                        |apply
                         |ARG     |  |ARG                    |
1923            .unwrap();
                       |apply
1924        });
            |}inner
            |}closure
1925      }
          |}func
1927      #[test]
          |OUTER_ATTR
1928      fn overflow_res_multiple_dispatch_async() {
          |FUNCTION                                 |func{
1931        run_in_task(|_cx| {
                       |apply
                        |ARG
                        |closure
                         |PARAM
                              |closure{
                              |return
                              |inner{
1932          let (mut runtime, dispatch_count) = setup(Mode::OverflowResAsync);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM      ||)tuple
                                                |assign|apply
                                                        |ARG                 |
1934            .execute(
                        |apply
1935              "overflow_res_multiple_dispatch_async.js",
                  |ARG                                    |
1936              r#"
                  |ARG
1953            .unwrap();
                       |apply
1954          assert_eq!(dispatch_count.load(Ordering::Relaxed), 2);
              |MACRO()| |macro(){                                 |}macro()
1955          poll_until_ready(&mut runtime, 3).unwrap();
                              |apply
                               |ARG       |  |arg     |apply
1957            .execute("check.js", "assert(asyncRecv == 2);")
                        |apply
                         |ARG     |  |ARG                    |
1958            .unwrap();
                       |apply
1959        });
            |}inner
            |}closure
1960      }
          |}func
1962      #[test]
          |OUTER_ATTR
1963      fn test_pre_dispatch() {
          |FUNCTION              |func{
1964        run_in_task(|mut cx| {
                       |apply
                        |ARG
                        |closure
                         |PARAM  |closure{
                                 |return
                                 |inner{
1965          let (mut runtime, _dispatch_count) = setup(Mode::OverflowResAsync);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM       ||)tuple
                                                 |assign|apply
                                                         |ARG                 |
1967            .execute(
                        |apply
1968              "bad_op_id.js",
                  |ARG         |
1969              r#"
                  |ARG
1979            .unwrap();
                       |apply
1980          if let Poll::Ready(Err(_)) = runtime.poll_event_loop(&mut cx) {
              |IF|VAR_DECL
                     |STRUCT()   |ARG |
                                 |STRUCT()
                                     |arg|assign                  |apply
                                                                   |ARG  |  |if{
1981            unreachable!();
                |MACRO()  | |macro(){
                             |}macro()
1982          }
              |}if
1983        });
            |}inner
            |}closure
1984      }
          |}func
1986      #[test]
          |OUTER_ATTR
1987      fn core_test_js() {
          |FUNCTION         |func{
1988        run_in_task(|mut cx| {
                       |apply
                        |ARG
                        |closure
                         |PARAM  |closure{
                                 |return
                                 |inner{
1989          let (mut runtime, _dispatch_count) = setup(Mode::Async);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM       ||)tuple
                                                 |assign|apply
                                                         |ARG      |
1991            .execute("core_test.js", include_str!("core_test.js"))
                        |apply
                         |ARG         |  |ARG                       |
                                         |MACRO()  | |macro(){      |}macro()
1992            .unwrap();
                       |apply
1993          if let Poll::Ready(Err(_)) = runtime.poll_event_loop(&mut cx) {
              |IF|VAR_DECL
                     |STRUCT()   |ARG |
                                 |STRUCT()
                                     |arg|assign                  |apply
                                                                   |ARG  |  |if{
1994            unreachable!();
                |MACRO()  | |macro(){
                             |}macro()
1995          }
              |}if
1996        });
            |}inner
            |}closure
1997      }
          |}func
1999      #[test]
          |OUTER_ATTR
2000      fn syntax_error() {
          |FUNCTION         |func{
2001        let mut runtime = JsRuntime::new(Default::default());
            |VAR_DECL       |assign         |apply
                                             |ARG             |
                                                             |apply
2002        let src = "hocuspocus(";
            |VAR_DECL
                    |assign
2003        let r = runtime.execute("i.js", src);
            |VAR_DECL
                  |assign          |apply
                                    |ARG |  |ARG
2004        let e = r.unwrap_err();
            |VAR_DECL
                  |assign       |apply
2005        let js_error = e.downcast::<JsError>().unwrap();
            |VAR_DECL    |assign        |T_ARG| |apply   |apply
2006        assert_eq!(js_error.end_column, Some(11));
            |MACRO()| |macro(){                     |}macro()
2007      }
          |}func
2009      #[test]
          |OUTER_ATTR
2010      fn test_encode_decode() {
          |FUNCTION               |func{
2011        run_in_task(|mut cx| {
                       |apply
                        |ARG
                        |closure
                         |PARAM  |closure{
                                 |return
                                 |inner{
2012          let (mut runtime, _dispatch_count) = setup(Mode::Async);
              |VAR_DECL
                  |tuple
                  |tuple(
                   |T_ELEM      |T_ELEM       ||)tuple
                                                 |assign|apply
                                                         |ARG      |
2014            .execute(
                        |apply
2015              "encode_decode_test.js",
                  |ARG                  |
2016              include_str!("encode_decode_test.js"),
                  |ARG                                |
                  |MACRO()  | |macro(){               |}macro()
2018            .unwrap();
                       |apply
2019          if let Poll::Ready(Err(_)) = runtime.poll_event_loop(&mut cx) {
              |IF|VAR_DECL
                     |STRUCT()   |ARG |
                                 |STRUCT()
                                     |arg|assign                  |apply
                                                                   |ARG  |  |if{
2020            unreachable!();
                |MACRO()  | |macro(){
                             |}macro()
2021          }
              |}if
2022        });
            |}inner
            |}closure
2023      }
          |}func
2025      #[test]
          |OUTER_ATTR
2026      fn will_snapshot() {
          |FUNCTION          |func{
2027        let snapshot = {
            |VAR_DECL    |assign
                           |inner{
2028          let mut runtime = JsRuntime::new(RuntimeOptions {
              |VAR_DECL       |assign         |apply
                                               |ARG
                                               |STRUCT()    |
2029            will_snapshot: true,
                |ARG              |
2030            ..Default::default()
                                  |apply
2032          runtime.execute("a.js", "a = 1 + 2").unwrap();
                             |apply
                              |ARG |  |ARG      |        |apply
2033          runtime.snapshot()
                              |apply
2034        };
            |}inner
2036        let snapshot = Snapshot::JustCreated(snapshot);
            |VAR_DECL    |assign                |apply
                                                 |ARG   |
2037        let mut runtime2 = JsRuntime::new(RuntimeOptions {
            |VAR_DECL        |assign         |apply
                                              |ARG
                                              |STRUCT()    |
2038          startup_snapshot: Some(snapshot),
              |ARG                           |
                                    |apply
                                     |ARG   |
2039          ..Default::default()
                                |apply
2042          .execute("check.js", "if (a != 3) throw Error('x')")
                      |apply
                       |ARG     |  |ARG                         |
2043          .unwrap();
                     |apply
2044      }
          |}func
2046      #[test]
          |OUTER_ATTR
2047      fn test_from_boxed_snapshot() {
          |FUNCTION                     |func{
2048        let snapshot = {
            |VAR_DECL    |assign
                           |inner{
2049          let mut runtime = JsRuntime::new(RuntimeOptions {
              |VAR_DECL       |assign         |apply
                                               |ARG
                                               |STRUCT()    |
2050            will_snapshot: true,
                |ARG              |
2051            ..Default::default()
                                  |apply
2053          runtime.execute("a.js", "a = 1 + 2").unwrap();
                             |apply
                              |ARG |  |ARG      |        |apply
2054          let snap: &[u8] = &*runtime.snapshot();
              |VAR_DECL       |assign             |apply
2055          Vec::from(snap).into_boxed_slice()
                       |apply
                        |ARG                  |apply
2056        };
            |}inner
2058        let snapshot = Snapshot::Boxed(snapshot);
            |VAR_DECL    |assign          |apply
                                           |ARG   |
2059        let mut runtime2 = JsRuntime::new(RuntimeOptions {
            |VAR_DECL        |assign         |apply
                                              |ARG
                                              |STRUCT()    |
2060          startup_snapshot: Some(snapshot),
              |ARG                           |
                                    |apply
                                     |ARG   |
2061          ..Default::default()
                                |apply
2064          .execute("check.js", "if (a != 3) throw Error('x')")
                      |apply
                       |ARG     |  |ARG                         |
2065          .unwrap();
                     |apply
2066      }
          |}func
2068      #[test]
          |OUTER_ATTR
2069      fn test_heap_limits() {
          |FUNCTION             |func{
2070        let create_params = v8::Isolate::create_params().heap_limits(0, 20 * 1024);
            |VAR_DECL         |assign                     |apply        |apply
                                                                         |arg
                                                                            |ARG    |
2071        let mut runtime = JsRuntime::new(RuntimeOptions {
            |VAR_DECL       |assign         |apply
                                             |ARG
                                             |STRUCT()    |
2072          create_params: Some(create_params),
              |ARG                             |
                                 |apply
                                  |ARG        |
2073          ..Default::default()
                                |apply
2075        let cb_handle = runtime.v8_isolate().thread_safe_handle();
            |VAR_DECL     |assign             |apply               |apply
2077        let callback_invoke_count = Rc::new(AtomicUsize::default());
            |VAR_DECL                 |assign  |apply
                                                |ARG                 |
                                                                    |apply
2078        let inner_invoke_count = Rc::clone(&callback_invoke_count);
            |VAR_DECL              |assign    |apply
                                               |ARG                 |
2080        runtime.add_near_heap_limit_callback(
                                                |apply
2081          move |current_limit, _initial_limit| {
              |ARG
              |CLOSURE
                    |PARAM      |  |PARAM       |  |closure{
                                                   |return
                                                   |inner{
2082            inner_invoke_count.fetch_add(1, Ordering::SeqCst);
                                            |apply
                                             |arg
                                                |ARG           |
2083            cb_handle.terminate_execution();
                                             |apply
2085          },
              |}inner
              |}closure
2087        let err = runtime
            |VAR_DECL
                    |assign
2088          .execute(
                      |apply
2089            "script name",
                |ARG        |
2090            r#"let s = ""; while(true) { s += "Hello"; }"#,
                |ARG                                         |
2092          .expect_err("script should fail");
                         |apply
                          |ARG               |
2093        assert_eq!(
            |MACRO()| |macro(){
2096        );
            |}macro()
2097        assert!(callback_invoke_count.load(Ordering::SeqCst) > 0)
            |MACRO()
                   |macro(){                                        |}macro()
2098      }
          |}func
2100      #[test]
          |OUTER_ATTR
2101      fn test_heap_limit_cb_remove() {
          |FUNCTION                      |func{
2102        let mut runtime = JsRuntime::new(Default::default());
            |VAR_DECL       |assign         |apply
                                             |ARG             |
                                                             |apply
2104        runtime.add_near_heap_limit_callback(|current_limit, _initial_limit| {
                                                |apply
                                                 |ARG
                                                 |closure
                                                  |PARAM      |  |PARAM       |  |closure{
                                                                                 |return
                                                                                 |inner{
2106        });
            |}inner
            |}closure
2107        runtime.remove_near_heap_limit_callback(20 * 1024);
                                                   |apply
                                                    |ARG    |
2108        assert!(runtime.allocations.near_heap_limit_callback_data.is_none());
            |MACRO()
                   |macro(){                                                   |}macro()
2109      }
          |}func
2111      #[test]
          |OUTER_ATTR
2112      fn test_heap_limit_cb_multiple() {
          |FUNCTION                        |func{
2113        let create_params = v8::Isolate::create_params().heap_limits(0, 20 * 1024);
            |VAR_DECL         |assign                     |apply        |apply
                                                                         |arg
                                                                            |ARG    |
2114        let mut runtime = JsRuntime::new(RuntimeOptions {
            |VAR_DECL       |assign         |apply
                                             |ARG
                                             |STRUCT()    |
2115          create_params: Some(create_params),
              |ARG                             |
                                 |apply
                                  |ARG        |
2116          ..Default::default()
                                |apply
2118        let cb_handle = runtime.v8_isolate().thread_safe_handle();
            |VAR_DECL     |assign             |apply               |apply
2120        let callback_invoke_count_first = Rc::new(AtomicUsize::default());
            |VAR_DECL                       |assign  |apply
                                                      |ARG                 |
                                                                          |apply
2121        let inner_invoke_count_first = Rc::clone(&callback_invoke_count_first);
            |VAR_DECL                    |assign    |apply
                                                     |ARG                       |
2122        runtime.add_near_heap_limit_callback(
                                                |apply
2123          move |current_limit, _initial_limit| {
              |ARG
              |CLOSURE
                    |PARAM      |  |PARAM       |  |closure{
                                                   |return
                                                   |inner{
2124            inner_invoke_count_first.fetch_add(1, Ordering::SeqCst);
                                                  |apply
                                                   |arg
                                                      |ARG           |
2126          },
              |}inner
              |}closure
2129        let callback_invoke_count_second = Rc::new(AtomicUsize::default());
            |VAR_DECL                        |assign  |apply
                                                       |ARG                 |
                                                                           |apply
2130        let inner_invoke_count_second = Rc::clone(&callback_invoke_count_second);
            |VAR_DECL                     |assign    |apply
                                                      |ARG                        |
2131        runtime.add_near_heap_limit_callback(
                                                |apply
2132          move |current_limit, _initial_limit| {
              |ARG
              |CLOSURE
                    |PARAM      |  |PARAM       |  |closure{
                                                   |return
                                                   |inner{
2133            inner_invoke_count_second.fetch_add(1, Ordering::SeqCst);
                                                   |apply
                                                    |arg
                                                       |ARG           |
2134            cb_handle.terminate_execution();
                                             |apply
2136          },
              |}inner
              |}closure
2139        let err = runtime
            |VAR_DECL
                    |assign
2140          .execute(
                      |apply
2141            "script name",
                |ARG        |
2142            r#"let s = ""; while(true) { s += "Hello"; }"#,
                |ARG                                         |
2144          .expect_err("script should fail");
                         |apply
                          |ARG               |
2145        assert_eq!(
            |MACRO()| |macro(){
2148        );
            |}macro()
2149        assert_eq!(0, callback_invoke_count_first.load(Ordering::SeqCst));
            |MACRO()| |macro(){                                             |}macro()
2150        assert!(callback_invoke_count_second.load(Ordering::SeqCst) > 0);
            |MACRO()
                   |macro(){                                               |}macro()
2151      }
          |}func
2153      #[test]
          |OUTER_ATTR
2154      fn test_mods() {
          |FUNCTION      |func{
2155        #[derive(Default)]
            |OUTER_ATTR      |
2156        struct ModsLoader {
            |STRUCT           |struct{
2157          pub count: Arc<AtomicUsize>,
              |FIELD
2158        }
            |}struct
2160        impl ModuleLoader for ModsLoader {
            |IMPL                            |impl{
2161          fn resolve(
              |FUNCTION
2162            &self,
                |PARAM
2163            _op_state: Rc<RefCell<OpState>>,
                |PARAM                        |
2164            specifier: &str,
                |PARAM        |
2165            referrer: &str,
                |PARAM       |
2166            _is_main: bool,
                |PARAM       |
2167          ) -> Result<ModuleSpecifier, AnyError> {
                                                     |func{
2168            self.count.fetch_add(1, Ordering::Relaxed);
                                    |apply
                                     |arg
                                        |ARG            |
2169            assert_eq!(specifier, "./b.js");
                |MACRO()| |macro(){           |}macro()
2170            assert_eq!(referrer, "file:///a.js");
                |MACRO()| |macro(){                |}macro()
2171            let s = ModuleSpecifier::resolve_import(specifier, referrer).unwrap();
                |VAR_DECL
                      |assign                          |apply
                                                        |ARG    |  |ARG   |        |apply
2172            Ok(s)
                  |apply
                   |arg
2173          }
              |}func
2175          fn load(
              |FUNCTION
2176            &self,
                |PARAM
2177            _op_state: Rc<RefCell<OpState>>,
                |PARAM                        |
2178            _module_specifier: &ModuleSpecifier,
                |PARAM                            |
2179            _maybe_referrer: Option<ModuleSpecifier>,
                |PARAM                                 |
2180            _is_dyn_import: bool,
                |PARAM             |
2181          ) -> Pin<Box<ModuleSourceFuture>> {
                                                |func{
2182            unreachable!()
                |MACRO()  | |macro(){
                             |}macro()
2183          }
              |}func
2184        }
            |}impl
2186        let loader = Rc::new(ModsLoader::default());
            |VAR_DECL  |assign  |apply
                                 |ARG                |
                                                    |apply
2188        let resolve_count = loader.count.clone();
            |VAR_DECL         |assign             |apply
2189        let dispatch_count = Arc::new(AtomicUsize::new(0));
            |VAR_DECL          |assign   |apply
                                          |ARG              |
                                                          |apply
                                                           |arg
2190        let dispatch_count_ = dispatch_count.clone();
            |VAR_DECL           |assign               |apply
2192        let dispatcher = move |_state: Rc<RefCell<OpState>>, bufs: BufVec| -> Op {
            |VAR_DECL      |assign
                             |CLOSURE
                                   |PARAM                        |PARAM              |closure{
2193          dispatch_count_.fetch_add(1, Ordering::Relaxed);
                                       |apply
                                        |arg
                                           |ARG            |
2194          assert_eq!(bufs.len(), 1);
              |MACRO()| |macro(){     |}macro()
2195          assert_eq!(bufs[0].len(), 1);
              |MACRO()| |macro(){        |}macro()
2196          assert_eq!(bufs[0][0], 42);
              |MACRO()| |macro(){      |}macro()
2197          let buf = [43u8, 0, 0, 0][..].into();
              |VAR_DECL
                      |assign
                        |array{
                         |ARRAY_ELEM
                               |array_elem
                                  |array_elem
                                     |array_elem
                                      |}array   |apply
2198          Op::Async(futures::future::ready(buf).boxed())
                       |apply
                        |ARG                              |
                                              |apply
                                               |ARG      |apply
2199        };
            |}closure
2201        let mut runtime = JsRuntime::new(RuntimeOptions {
            |VAR_DECL       |assign         |apply
                                             |ARG
                                             |STRUCT()    |
2202          module_loader: Some(loader),
              |ARG                      |
                                 |apply
                                  |ARG |
2203          ..Default::default()
                                |apply
2205        runtime.register_op("test", dispatcher);
                               |apply
                                |ARG |  |ARG     |
2208          .execute(
                      |apply
2209            "setup.js",
                |ARG     |
2210            r#"
                |ARG
2218          .unwrap();
                     |apply
2220        assert_eq!(dispatch_count.load(Ordering::Relaxed), 0);
            |MACRO()| |macro(){                                 |}macro()
2222        let specifier_a = "file:///a.js".to_string();
            |VAR_DECL       |assign                   |apply
2223        let mod_a = runtime
            |VAR_DECL |assign
2224          .mod_new(
                      |apply
2225            true,
                |ARG
2226            &specifier_a,
                |ARG       |
2227            r#"
                |ARG
2234          .unwrap();
                     |apply
2235        assert_eq!(dispatch_count.load(Ordering::Relaxed), 0);
            |MACRO()| |macro(){                                 |}macro()
2237        let state_rc = JsRuntime::state(runtime.v8_isolate());
            |VAR_DECL    |assign           |apply
                                            |ARG               |
                                                              |apply
2238        {
            |inner{
2239          let state = state_rc.borrow();
              |VAR_DECL |assign          |apply
2240          let imports = state.modules.get_children(mod_a);
              |VAR_DECL   |assign                     |apply
                                                       |ARG|
2241          assert_eq!(
              |MACRO()| |macro(){
2244          );
              |}macro()
2245        }
            |}inner
2246        let mod_b = runtime
            |VAR_DECL |assign
2247          .mod_new(false, "file:///b.js", "export function b() { return 'b' }")
                      |apply
                       |ARG|  |ARG         |  |ARG                               |
2248          .unwrap();
                     |apply
2249        {
            |inner{
2250          let state = state_rc.borrow();
              |VAR_DECL |assign          |apply
2251          let imports = state.modules.get_children(mod_b).unwrap();
              |VAR_DECL   |assign                     |apply
                                                       |ARG|        |apply
2252          assert_eq!(imports.len(), 0);
              |MACRO()| |macro(){        |}macro()
2253        }
            |}inner
2255        runtime.mod_instantiate(mod_b).unwrap();
                                   |apply
                                    |ARG|        |apply
2256        assert_eq!(dispatch_count.load(Ordering::Relaxed), 0);
            |MACRO()| |macro(){                                 |}macro()
2257        assert_eq!(resolve_count.load(Ordering::SeqCst), 1);
            |MACRO()| |macro(){                               |}macro()
2259        runtime.mod_instantiate(mod_a).unwrap();
                                   |apply
                                    |ARG|        |apply
2260        assert_eq!(dispatch_count.load(Ordering::Relaxed), 0);
            |MACRO()| |macro(){                                 |}macro()
2262        runtime.mod_evaluate_inner(mod_a);
                                      |apply
                                       |ARG|
2263        assert_eq!(dispatch_count.load(Ordering::Relaxed), 1);
            |MACRO()| |macro(){                                 |}macro()
2264      }
          |}func
2266      #[test]
          |OUTER_ATTR
2267      fn dyn_import_err() {
          |FUNCTION           |func{
2268        #[derive(Clone, Default)]
            |OUTER_ATTR             |
2269        struct DynImportErrLoader {
            |STRUCT                   |struct{
2270          pub count: Arc<AtomicUsize>,
              |FIELD
2271        }
            |}struct
2273        impl ModuleLoader for DynImportErrLoader {
            |IMPL                                    |impl{
2274          fn resolve(
              |FUNCTION
2275            &self,
                |PARAM
2276            _op_state: Rc<RefCell<OpState>>,
                |PARAM                        |
2277            specifier: &str,
                |PARAM        |
2278            referrer: &str,
                |PARAM       |
2279            _is_main: bool,
                |PARAM       |
2280          ) -> Result<ModuleSpecifier, AnyError> {
                                                     |func{
2281            self.count.fetch_add(1, Ordering::Relaxed);
                                    |apply
                                     |arg
                                        |ARG            |
2282            assert_eq!(specifier, "/foo.js");
                |MACRO()| |macro(){            |}macro()
2283            assert_eq!(referrer, "file:///dyn_import2.js");
                |MACRO()| |macro(){                          |}macro()
2284            let s = ModuleSpecifier::resolve_import(specifier, referrer).unwrap();
                |VAR_DECL
                      |assign                          |apply
                                                        |ARG    |  |ARG   |        |apply
2285            Ok(s)
                  |apply
                   |arg
2286          }
              |}func
2288          fn load(
              |FUNCTION
2289            &self,
                |PARAM
2290            _op_state: Rc<RefCell<OpState>>,
                |PARAM                        |
2291            _module_specifier: &ModuleSpecifier,
                |PARAM                            |
2292            _maybe_referrer: Option<ModuleSpecifier>,
                |PARAM                                 |
2293            _is_dyn_import: bool,
                |PARAM             |
2294          ) -> Pin<Box<ModuleSourceFuture>> {
                                                |func{
2295            async { Err(io::Error::from(io::ErrorKind::NotFound).into()) }.boxed()
                      |inner{
                           |apply
                            |ARG                                          |
                                           |apply
                                            |ARG                  |      |apply
                                                                             |}inner|apply
2296          }
              |}func
2297        }
            |}impl
2300        run_in_task(|cx| {
                       |apply
                        |ARG
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{
2301          let loader = Rc::new(DynImportErrLoader::default());
              |VAR_DECL  |assign  |apply
                                   |ARG                        |
                                                              |apply
2302          let count = loader.count.clone();
              |VAR_DECL |assign             |apply
2303          let mut runtime = JsRuntime::new(RuntimeOptions {
              |VAR_DECL       |assign         |apply
                                               |ARG
                                               |STRUCT()    |
2304            module_loader: Some(loader),
                |ARG                      |
                                   |apply
                                    |ARG |
2305            ..Default::default()
                                  |apply
2309            .execute(
                        |apply
2310              "file:///dyn_import2.js",
                  |ARG                   |
2311              r#"
                  |ARG
2317            .unwrap();
                       |apply
2319          assert_eq!(count.load(Ordering::Relaxed), 0);
              |MACRO()| |macro(){                        |}macro()
2321          let result = runtime.poll_event_loop(cx);
              |VAR_DECL  |assign                  |apply
                                                   |ARG
2322          if let Poll::Ready(Ok(_)) = result {
              |IF|VAR_DECL
                     |STRUCT()   |ARG|
                                 |STRUCT()
                                    |arg|assign  |if{
2323            unreachable!();
                |MACRO()  | |macro(){
                             |}macro()
2324          }
              |}if
2325          assert_eq!(count.load(Ordering::Relaxed), 2);
              |MACRO()| |macro(){                        |}macro()
2326        })
            |}inner
            |}closure
2327      }
          |}func
2329      #[derive(Clone, Default)]
          |OUTER_ATTR             |
2330      struct DynImportOkLoader {
          |STRUCT                  |struct{
2331        pub prepare_load_count: Arc<AtomicUsize>,
            |FIELD
2332        pub resolve_count: Arc<AtomicUsize>,
            |FIELD
2333        pub load_count: Arc<AtomicUsize>,
            |FIELD
2334      }
          |}struct
2336      impl ModuleLoader for DynImportOkLoader {
          |IMPL                                   |impl{
2337        fn resolve(
            |FUNCTION
2338          &self,
              |PARAM
2339          _op_state: Rc<RefCell<OpState>>,
              |PARAM                        |
2340          specifier: &str,
              |PARAM        |
2341          referrer: &str,
              |PARAM       |
2342          _is_main: bool,
              |PARAM       |
2343        ) -> Result<ModuleSpecifier, AnyError> {
                                                   |func{
2344          let c = self.resolve_count.fetch_add(1, Ordering::Relaxed);
              |VAR_DECL
                    |assign                       |apply
                                                   |arg
                                                      |ARG            |
2345          assert!(c < 4);
              |MACRO()
                     |macro(){
                           |}macro()
2346          assert_eq!(specifier, "./b.js");
              |MACRO()| |macro(){           |}macro()
2347          assert_eq!(referrer, "file:///dyn_import3.js");
              |MACRO()| |macro(){                          |}macro()
2348          let s = ModuleSpecifier::resolve_import(specifier, referrer).unwrap();
              |VAR_DECL
                    |assign                          |apply
                                                      |ARG    |  |ARG   |        |apply
2349          Ok(s)
                |apply
                 |arg
2350        }
            |}func
2352        fn load(
            |FUNCTION
2353          &self,
              |PARAM
2354          _op_state: Rc<RefCell<OpState>>,
              |PARAM                        |
2355          specifier: &ModuleSpecifier,
              |PARAM                    |
2356          _maybe_referrer: Option<ModuleSpecifier>,
              |PARAM                                 |
2357          _is_dyn_import: bool,
              |PARAM             |
2358        ) -> Pin<Box<ModuleSourceFuture>> {
                                              |func{
2359          self.load_count.fetch_add(1, Ordering::Relaxed);
                                       |apply
                                        |arg
                                           |ARG            |
2360          let info = ModuleSource {
              |VAR_DECL|assign
                         |STRUCT()  |
2361            module_url_specified: specifier.to_string(),
                |ARG                                      |
                                                         |apply
2362            module_url_found: specifier.to_string(),
                |ARG                                  |
                                                     |apply
2363            code: "export function b() { return 'b' }".to_owned(),
                |ARG                                                |
                                                                   |apply
2365          async move { Ok(info) }.boxed()
                         |inner{
                             |apply
                              |ARG  |}inner|apply
2366        }
            |}func
2368        fn prepare_load(
            |FUNCTION
2369          &self,
              |PARAM
2370          _op_state: Rc<RefCell<OpState>>,
              |PARAM                        |
2371          _load_id: ModuleLoadId,
              |PARAM               |
2372          _module_specifier: &ModuleSpecifier,
              |PARAM                            |
2373          _maybe_referrer: Option<String>,
              |PARAM                        |
2374          _is_dyn_import: bool,
              |PARAM             |
2375        ) -> Pin<Box<dyn Future<Output = Result<(), AnyError>>>> {
                                                                     |func{
2376          self.prepare_load_count.fetch_add(1, Ordering::Relaxed);
                                               |apply
                                                |arg
                                                   |ARG            |
2377          async { Ok(()) }.boxed_local()
                    |inner{
                        |apply
                         |ARG
                         |tuple(
                          |)tuple
                             |}inner      |apply
2378        }
            |}func
2379      }
          |}impl
2381      #[test]
          |OUTER_ATTR
2382      fn dyn_import_ok() {
          |FUNCTION          |func{
2383        run_in_task(|cx| {
                       |apply
                        |ARG
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{
2384          let loader = Rc::new(DynImportOkLoader::default());
              |VAR_DECL  |assign  |apply
                                   |ARG                       |
                                                             |apply
2385          let prepare_load_count = loader.prepare_load_count.clone();
              |VAR_DECL              |assign                          |apply
2386          let resolve_count = loader.resolve_count.clone();
              |VAR_DECL         |assign                     |apply
2387          let load_count = loader.load_count.clone();
              |VAR_DECL      |assign                  |apply
2388          let mut runtime = JsRuntime::new(RuntimeOptions {
              |VAR_DECL       |assign         |apply
                                               |ARG
                                               |STRUCT()    |
2389            module_loader: Some(loader),
                |ARG                      |
                                   |apply
                                    |ARG |
2390            ..Default::default()
                                  |apply
2395            .execute(
                        |apply
2396              "file:///dyn_import3.js",
                  |ARG                   |
2397              r#"
                  |ARG
2411            .unwrap();
                       |apply
2414          assert!(matches!(runtime.poll_event_loop(cx), Poll::Pending));
              |MACRO()
                     |macro(){                                            |}macro()
2415          assert_eq!(prepare_load_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                     |}macro()
2418          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()
2419          assert_eq!(resolve_count.load(Ordering::Relaxed), 4);
              |MACRO()| |macro(){                                |}macro()
2420          assert_eq!(load_count.load(Ordering::Relaxed), 2);
              |MACRO()| |macro(){                             |}macro()
2421          assert!(matches!(runtime.poll_event_loop(cx), Poll::Ready(Ok(_))));
              |MACRO()
                     |macro(){                                                 |}macro()
2422          assert_eq!(resolve_count.load(Ordering::Relaxed), 4);
              |MACRO()| |macro(){                                |}macro()
2423          assert_eq!(load_count.load(Ordering::Relaxed), 2);
              |MACRO()| |macro(){                             |}macro()
2424        })
            |}inner
            |}closure
2425      }
          |}func
2427      #[test]
          |OUTER_ATTR
2428      fn dyn_import_borrow_mut_error() {
          |FUNCTION                        |func{
2430        run_in_task(|cx| {
                       |apply
                        |ARG
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{
2431          let loader = Rc::new(DynImportOkLoader::default());
              |VAR_DECL  |assign  |apply
                                   |ARG                       |
                                                             |apply
2432          let prepare_load_count = loader.prepare_load_count.clone();
              |VAR_DECL              |assign                          |apply
2433          let mut runtime = JsRuntime::new(RuntimeOptions {
              |VAR_DECL       |assign         |apply
                                               |ARG
                                               |STRUCT()    |
2434            module_loader: Some(loader),
                |ARG                      |
                                   |apply
                                    |ARG |
2435            ..Default::default()
                                  |apply
2438            .execute(
                        |apply
2439              "file:///dyn_import3.js",
                  |ARG                   |
2440              r#"
                  |ARG
2451            .unwrap();
                       |apply
2453          let _ = runtime.poll_event_loop(cx);
              |VAR_DECL
                    |assign                  |apply
                                              |ARG
2454          assert_eq!(prepare_load_count.load(Ordering::Relaxed), 1);
              |MACRO()| |macro(){                                     |}macro()
2456          let _ = runtime.poll_event_loop(cx);
              |VAR_DECL
                    |assign                  |apply
                                              |ARG
2457        })
            |}inner
            |}closure
2458      }
          |}func
2460      #[test]
          |OUTER_ATTR
2461      fn es_snapshot() {
          |FUNCTION        |func{
2462        #[derive(Default)]
            |OUTER_ATTR      |
2463        struct ModsLoader;
            |STRUCT
2465        impl ModuleLoader for ModsLoader {
            |IMPL                            |impl{
2466          fn resolve(
              |FUNCTION
2467            &self,
                |PARAM
2468            _op_state: Rc<RefCell<OpState>>,
                |PARAM                        |
2469            specifier: &str,
                |PARAM        |
2470            referrer: &str,
                |PARAM       |
2471            _is_main: bool,
                |PARAM       |
2472          ) -> Result<ModuleSpecifier, AnyError> {
                                                     |func{
2473            assert_eq!(specifier, "file:///main.js");
                |MACRO()| |macro(){                    |}macro()
2474            assert_eq!(referrer, ".");
                |MACRO()| |macro(){     |}macro()
2475            let s = ModuleSpecifier::resolve_import(specifier, referrer).unwrap();
                |VAR_DECL
                      |assign                          |apply
                                                        |ARG    |  |ARG   |        |apply
2476            Ok(s)
                  |apply
                   |arg
2477          }
              |}func
2479          fn load(
              |FUNCTION
2480            &self,
                |PARAM
2481            _op_state: Rc<RefCell<OpState>>,
                |PARAM                        |
2482            _module_specifier: &ModuleSpecifier,
                |PARAM                            |
2483            _maybe_referrer: Option<ModuleSpecifier>,
                |PARAM                                 |
2484            _is_dyn_import: bool,
                |PARAM             |
2485          ) -> Pin<Box<ModuleSourceFuture>> {
                                                |func{
2486            unreachable!()
                |MACRO()  | |macro(){
                             |}macro()
2487          }
              |}func
2488        }
            |}impl
2490        let loader = std::rc::Rc::new(ModsLoader::default());
            |VAR_DECL  |assign           |apply
                                          |ARG                |
                                                             |apply
2491        let mut runtime = JsRuntime::new(RuntimeOptions {
            |VAR_DECL       |assign         |apply
                                             |ARG
                                             |STRUCT()    |
2492          module_loader: Some(loader),
              |ARG                      |
                                 |apply
                                  |ARG |
2493          will_snapshot: true,
              |ARG              |
2494          ..Default::default()
                                |apply
2497        let specifier = ModuleSpecifier::resolve_url("file:///main.js").unwrap();
            |VAR_DECL     |assign                       |apply
                                                         |ARG            |        |apply
2498        let source_code = "Deno.core.print('hello\\n')".to_string();
            |VAR_DECL       |assign                                  |apply
2500        let module_id = futures::executor::block_on(
            |VAR_DECL     |assign                      |apply
2501          runtime.load_module(&specifier, Some(source_code)),
              |ARG                                             |
                                 |apply
                                  |ARG     |  |ARG            |
                                                  |apply
                                                   |ARG      |
2503        .unwrap();
                   |apply
2505        futures::executor::block_on(runtime.mod_evaluate(module_id)).unwrap();
                                       |apply
                                        |ARG                          |
                                                            |apply
                                                             |ARG    |         |apply
2507        let _snapshot = runtime.snapshot();
            |VAR_DECL     |assign           |apply
2508      }
          |}func
2510      #[test]
          |OUTER_ATTR
2511      fn test_error_without_stack() {
          |FUNCTION                     |func{
2512        let mut runtime = JsRuntime::new(RuntimeOptions::default());
            |VAR_DECL       |assign         |apply
                                             |ARG                    |
                                                                    |apply
2514        let result = runtime.execute(
            |VAR_DECL  |assign          |apply
2515          "error_without_stack.js",
              |ARG                   |
2516          r#"
              |ARG
2523        let expected_error = r#"Uncaught SyntaxError: Invalid or unexpected token
            |VAR_DECL          |assign
2525        assert_eq!(result.unwrap_err().to_string(), expected_error);
            |MACRO()| |macro(){                                       |}macro()
2526      }
          |}func
2528      #[test]
          |OUTER_ATTR
2529      fn test_error_stack() {
          |FUNCTION             |func{
2530        let mut runtime = JsRuntime::new(RuntimeOptions::default());
            |VAR_DECL       |assign         |apply
                                             |ARG                    |
                                                                    |apply
2531        let result = runtime.execute(
            |VAR_DECL  |assign          |apply
2532          "error_stack.js",
              |ARG           |
2533          r#"
              |ARG
2545        let expected_error = r#"Error: assert
            |VAR_DECL          |assign
2549        assert_eq!(result.unwrap_err().to_string(), expected_error);
            |MACRO()| |macro(){                                       |}macro()
2550      }
          |}func
2552      #[test]
          |OUTER_ATTR
2553      fn test_error_async_stack() {
          |FUNCTION                   |func{
2554        run_in_task(|cx| {
                       |apply
                        |ARG
                        |closure
                         |PARAM
                             |closure{
                             |return
                             |inner{
2555          let mut runtime = JsRuntime::new(RuntimeOptions::default());
              |VAR_DECL       |assign         |apply
                                               |ARG                    |
                                                                      |apply
2557            .execute(
                        |apply
2558              "error_async_stack.js",
                  |ARG                 |
2559              r#"
                  |ARG
2574            .unwrap();
                       |apply
2575          let expected_error = r#"Error: async
              |VAR_DECL          |assign
2580          match runtime.poll_event_loop(cx) {
              |MATCH                       |apply
                                            |ARG|match{
2581            Poll::Ready(Err(e)) => {
                |CASE
                |STRUCT()   |ARG |
                            |STRUCT()
                                |arg   |inner{
2582              assert_eq!(e.to_string(), expected_error);
                  |MACRO()| |macro(){                     |}macro()
2583            }
                |}inner
2584            _ => panic!(),
                |case|MACRO()
                           |macro(){
                            |}macro()
2585          };
              |}match
2586        })
            |}inner
            |}closure
2587      }
          |}func
2589      #[test]
          |OUTER_ATTR
2590      fn test_core_js_stack_frame() {
          |FUNCTION                     |func{
2591        let mut runtime = JsRuntime::new(RuntimeOptions::default());
            |VAR_DECL       |assign         |apply
                                             |ARG                    |
                                                                    |apply
2593        let error = runtime
            |VAR_DECL |assign
2594          .execute(
                      |apply
2595            "core_js_stack_frame.js",
                |ARG                   |
2596            "Deno.core.dispatchByName('non_existent');",
                |ARG                                      |
2598          .unwrap_err();
                         |apply
2599        let error_string = error.to_string();
            |VAR_DECL        |assign          |apply
2601        assert!(error_string.contains("deno:core/core.js"));
            |MACRO()
                   |macro(){                                  |}macro()
2602      }
          |}func
2603    }
        |}module
        |<eof>